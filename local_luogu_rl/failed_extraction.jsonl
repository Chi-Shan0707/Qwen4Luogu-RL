{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P1008 [NOIP 1998 普及组] 三连击\n\n\n## 题目背景\n\n本题为提交答案题，您可以写程序或手算在本机上算出答案后，直接提交答案文本，也可提交答案生成程序。\n\n## 题目描述\n\n将 $1, 2, \\ldots , 9$ 共 $9$ 个数分成 $3$ 组，分别组成 $3$ 个三位数，且使这 $3$ 个三位数构成 $1 : 2 : 3$ 的比例，试求出所有满足条件的 $3$ 个三位数。\n\n## 输入格式\n\n无\n\n## 输出格式\n\n若干行，每行 $3$ 个数字。按照每行第 $1$ 个数字升序排列。\n\n## 说明/提示\n\nNOIP1998 普及组 第一题\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n无\n```\n\n**输出：**\n```\n192 384 576\n* * *\n...\n\n* * *\n（剩余部分不予展示）\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P1008 [NOIP 1998 普及组] 三连击\n\n\n## 题目背景\n\n本题为提交答案题，您可以写程序或手算在本机上算出答案后，直接提交答案文本，也可提交答案生成程序。\n\n## 题目描述\n\n将 $1, 2, \\ldots , 9$ 共 $9$ 个数分成 $3$ 组，分别组成 $3$ 个三位数，且使这 $3$ 个三位数构成 $1 : 2 : 3$ 的比例，试求出所有满足条件的 $3$ 个三位数。\n\n## 输入格式\n\n无\n\n## 输出格式\n\n若干行，每行 $3$ 个数字。按照每行第 $1$ 个数字升序排列。\n\n## 说明/提示\n\nNOIP1998 普及组 第一题\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n无\n```\n\n**输出：**\n```\n192 384 576\n* * *\n...\n\n* * *\n（剩余部分不予展示）\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P1274 魔术数字游戏\n\n\n## 题目描述\n\n填数字方格的游戏有很多种变化，如下图所示的 $4 \\times 4$ 方格中，我们要选择从数字 $1$ 到 $16$ 来填满这十六个格子($A_{i,j}$ ，其中 $i=1 \\cdots 4$ ，$j=1 \\cdots 4$)。为了让游戏更有挑战性，我们要求下列六项中的每一项所指定的四个格子，其数字累加的和必须为 $34$ ：\n| $A_{1,1}$ | $A_{1,2}$ | $A_{1,3}$ |  $A_{1,4}$|\n| :----------- | :----------- | :----------- | :----------- |\n| $A_{2,1}$ | $A_{2,2}$ | $A_{2,3}$ | $A_{2,4}$ |\n| $A_{3,1}$ | $A_{3,2}$ | $A_{3,3}$ | $A_{3,4}$ |\n| $A_{4,1}$ | $A_{4,2}$ | $A_{4,3}$ | $A_{4,4}$ |\n- 四个角落上的数字，即 $A_{1,1}+A_{1,4}+A_{4,1}+A_{4,4}=34$ 。\n- 每个角落上的 $2 \\times 2$ 方格中的数字，例如左上角 $A_{1,1}+A_{1,2}+A_{2,1}+A_{2,2}=34$ 。\n- 最中间的 $2 \\times 2$ 方格中的数字，即 $A_{2,2}+A_{2,3}+A_{3,2}+A_{3,3}=34$ 。\n- 每条水平线上四个格子中的数字，即 $A_{i,1}+A_{i,2}+A_{i,3}+A_{i,4}=34$，其中 $i=1 \\cdots 4$ 。\n- 每条垂直线上四个格子中的数字，即 $A_{1,j}+A_{2,j}+A_{3,j}+A_{4,j}=34$，其中 $j=1 \\cdots 4$ 。\n- 两条对角线上四个格子中的数字，例如左上角到右下角 $A_{1,1}+A_{2,2}+A_{3,3}+A_{4,4}=34$ 。\n- 右上角到左下角：$A_{1,4}+A_{2,3}+A_{3,2}+A_{4,1}=34$ 。\n特别的，我们会指定把数字 $1$ 先固定在某一格内。\n\n## 输入格式\n\n输入只有一行包含两个正数据 $i$ 和 $j$ ，表示第 $i$ 行和第 $j$ 列的格子放数字 $1$。剩下的十五个格子，请按照前述六项条件用数字 $2$ 到 $16$ 来填满。\n\n## 输出格式\n\n输出所有合法解，并且依序排好。相邻两组合法解之间用一个空行隔开。\n对于每一组合法解，输出四行，每行四个数，相邻两数之间用一个空格隔开。\n合法解排序的方式，是先从第一行的数字开始比较，每一行数字，由最左边的数字开始比，数字较小的解答必须先输出到文件中。\n\n## 说明/提示\n\n可以得到，对于样例，合理的填写方法有 $216$ 种，以上仅为其中的两种。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq i, j \\leq 4$。\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n1 1\n```\n\n**输出：**\n```\n1 4 13 16 \n14 15 2 3 \n8 5 12 9 \n11 10 7 6 \n\n1 4 13 16 \n14 15 2 3 \n12 9 8 5 \n7 6 11 10 \n\n……剩余214组合法解省略\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P1274 魔术数字游戏\n\n\n## 题目描述\n\n填数字方格的游戏有很多种变化，如下图所示的 $4 \\times 4$ 方格中，我们要选择从数字 $1$ 到 $16$ 来填满这十六个格子($A_{i,j}$ ，其中 $i=1 \\cdots 4$ ，$j=1 \\cdots 4$)。为了让游戏更有挑战性，我们要求下列六项中的每一项所指定的四个格子，其数字累加的和必须为 $34$ ：\n| $A_{1,1}$ | $A_{1,2}$ | $A_{1,3}$ |  $A_{1,4}$|\n| :----------- | :----------- | :----------- | :----------- |\n| $A_{2,1}$ | $A_{2,2}$ | $A_{2,3}$ | $A_{2,4}$ |\n| $A_{3,1}$ | $A_{3,2}$ | $A_{3,3}$ | $A_{3,4}$ |\n| $A_{4,1}$ | $A_{4,2}$ | $A_{4,3}$ | $A_{4,4}$ |\n- 四个角落上的数字，即 $A_{1,1}+A_{1,4}+A_{4,1}+A_{4,4}=34$ 。\n- 每个角落上的 $2 \\times 2$ 方格中的数字，例如左上角 $A_{1,1}+A_{1,2}+A_{2,1}+A_{2,2}=34$ 。\n- 最中间的 $2 \\times 2$ 方格中的数字，即 $A_{2,2}+A_{2,3}+A_{3,2}+A_{3,3}=34$ 。\n- 每条水平线上四个格子中的数字，即 $A_{i,1}+A_{i,2}+A_{i,3}+A_{i,4}=34$，其中 $i=1 \\cdots 4$ 。\n- 每条垂直线上四个格子中的数字，即 $A_{1,j}+A_{2,j}+A_{3,j}+A_{4,j}=34$，其中 $j=1 \\cdots 4$ 。\n- 两条对角线上四个格子中的数字，例如左上角到右下角 $A_{1,1}+A_{2,2}+A_{3,3}+A_{4,4}=34$ 。\n- 右上角到左下角：$A_{1,4}+A_{2,3}+A_{3,2}+A_{4,1}=34$ 。\n特别的，我们会指定把数字 $1$ 先固定在某一格内。\n\n## 输入格式\n\n输入只有一行包含两个正数据 $i$ 和 $j$ ，表示第 $i$ 行和第 $j$ 列的格子放数字 $1$。剩下的十五个格子，请按照前述六项条件用数字 $2$ 到 $16$ 来填满。\n\n## 输出格式\n\n输出所有合法解，并且依序排好。相邻两组合法解之间用一个空行隔开。\n对于每一组合法解，输出四行，每行四个数，相邻两数之间用一个空格隔开。\n合法解排序的方式，是先从第一行的数字开始比较，每一行数字，由最左边的数字开始比，数字较小的解答必须先输出到文件中。\n\n## 说明/提示\n\n可以得到，对于样例，合理的填写方法有 $216$ 种，以上仅为其中的两种。\n\n#### 数据规模与约定\n\n对于全部的测试点，保证 $1 \\leq i, j \\leq 4$。\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n1 1\n```\n\n**输出：**\n```\n1 4 13 16 \n14 15 2 3 \n8 5 12 9 \n11 10 7 6 \n\n1 4 13 16 \n14 15 2 3 \n12 9 8 5 \n7 6 11 10 \n\n……剩余214组合法解省略\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P2112 鸿雁传书\n\n\n## 题目背景\n\n小明给小红写了一封情书，他想把文章变得更完美，所以要进行排版。\n\n## 题目描述\n\n他一共写了 $N$ 个单词，为了美观，要把 $N$ 个单词分成 $K$ 行。单词的相对顺序不能变化。为了简化问题，无需考虑单词间的空格。\n小红会喜欢整齐的情书，小明想赢得小红的芳心，所以，他找到你，想让你帮他写一个程序，帮他排版，使得每行字母数的方差最小。请你求出最小的方差。\n\n## 输入格式\n\n第 $1$ 行，两个正整数 $N,K$。\n第 $2$ 行，$N$ 个空格隔开的单词。\n\n## 输出格式\n\n一行，一个 $1$ 位小数表示每行字母数的最小方差。\n\n## 说明/提示\n\n【样例说明】\n```plain\nxxx xxxxx\nxxxx xx\n```\n\n$1 \\div 2 \\times ((8-7)^2+(6-7)^2) = 1$。\n【数据范围】\n对于 $30\\%$ 数据，$N \\leq 100$，$K \\leq 3$。\n对于全部数据，$N \\leq 1000$，$K \\leq 100$，单词长度 $\\leq 20$。\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n4 2\nxxx xxxxx xxxx xx\n（输入的本来是一封情书，被和谐了……）\n```\n\n**输出：**\n```\n1.0\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P2112 鸿雁传书\n\n\n## 题目背景\n\n小明给小红写了一封情书，他想把文章变得更完美，所以要进行排版。\n\n## 题目描述\n\n他一共写了 $N$ 个单词，为了美观，要把 $N$ 个单词分成 $K$ 行。单词的相对顺序不能变化。为了简化问题，无需考虑单词间的空格。\n小红会喜欢整齐的情书，小明想赢得小红的芳心，所以，他找到你，想让你帮他写一个程序，帮他排版，使得每行字母数的方差最小。请你求出最小的方差。\n\n## 输入格式\n\n第 $1$ 行，两个正整数 $N,K$。\n第 $2$ 行，$N$ 个空格隔开的单词。\n\n## 输出格式\n\n一行，一个 $1$ 位小数表示每行字母数的最小方差。\n\n## 说明/提示\n\n【样例说明】\n```plain\nxxx xxxxx\nxxxx xx\n```\n\n$1 \\div 2 \\times ((8-7)^2+(6-7)^2) = 1$。\n【数据范围】\n对于 $30\\%$ 数据，$N \\leq 100$，$K \\leq 3$。\n对于全部数据，$N \\leq 1000$，$K \\leq 100$，单词长度 $\\leq 20$。\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n4 2\nxxx xxxxx xxxx xx\n（输入的本来是一封情书，被和谐了……）\n```\n\n**输出：**\n```\n1.0\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P2593 [ZJOI2006] 超级麻将\n\n\n## 题目描述\n\n很多人都知道玩麻将，当然也有人不知道，呵呵，不要紧，我在这里简要地介绍一下麻将规则：\n普通麻将有砣、索、万三种类型的牌，每种牌有 $1\\sim9$ 个数字，其中相同的牌每个有四张，例如 `1砣`\\~`9砣`，`1索`\\~`9索`，`1万`\\~`9万` 各有 $4$ 张，所以共 $36\\times 3=108$ 张牌。胡牌时每人有 $14$ 张牌，其中只要某人手里有若干句话（就是同种类型的牌连续三张或同种牌三张），另外再加上一对，即可胡牌。当然如果全是对，叫七小对，也可以胡牌。下图是连三张示例。\n\n要判断某人是否胡牌，显然一个弱智的算法就行了，某中学信息学小组超级麻将迷想了想，决定将普通麻将改造成超级麻将。\n所谓超级麻将没有了砣、索、万的区分，每种牌上的数字可以是 $1\\sim100$，而每种数字的牌各有 $100$ 张。另外特别自由的是，玩牌的人手里想拿多少张牌都可以，好刺激哦！\n刺激归刺激，但是拿多了怎么胡牌呢？\n超级麻将规定只要一个人手里拿的牌是若干句话（三个连续数字的牌各一张组成一句话，三张或者四张同样数字的牌也算一句话），再加上一对相同的牌，就算胡了。\n作为信息学竞赛选手的你，麻烦你给这位超级麻将迷编个程序，判断能否胡牌。\n\n## 输入格式\n\n输入文件第一行一个整数 $N(N\\le 100)$，表示玩了N次超级麻将。\n接下来N行，每行 $100$ 个数 $a_1 \\dots a_{100}$，描述每次玩牌手中各种牌的数量。$a_i$表示数字为i的牌有 $a_i$ 张。$(0\\le ai\\le 100)$\n\n## 输出格式\n\n输出 $N$ 行，若胡了则输出 `Yes`，否则输出 `No`，注意区分 `Yes`，`No` 的大小写！\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n3\n\n2 4 0 0 0 0 0 …… 0（一共98个0）\n\n2 4 2 0 0 0 0 …… 0（一共97个0）\n\n2 3 2 0 0 0 0 …… 0（一共97个0）\n```\n\n**输出：**\n```\nYes\n\nYes\n\nNo\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P2593 [ZJOI2006] 超级麻将\n\n\n## 题目描述\n\n很多人都知道玩麻将，当然也有人不知道，呵呵，不要紧，我在这里简要地介绍一下麻将规则：\n普通麻将有砣、索、万三种类型的牌，每种牌有 $1\\sim9$ 个数字，其中相同的牌每个有四张，例如 `1砣`\\~`9砣`，`1索`\\~`9索`，`1万`\\~`9万` 各有 $4$ 张，所以共 $36\\times 3=108$ 张牌。胡牌时每人有 $14$ 张牌，其中只要某人手里有若干句话（就是同种类型的牌连续三张或同种牌三张），另外再加上一对，即可胡牌。当然如果全是对，叫七小对，也可以胡牌。下图是连三张示例。\n\n要判断某人是否胡牌，显然一个弱智的算法就行了，某中学信息学小组超级麻将迷想了想，决定将普通麻将改造成超级麻将。\n所谓超级麻将没有了砣、索、万的区分，每种牌上的数字可以是 $1\\sim100$，而每种数字的牌各有 $100$ 张。另外特别自由的是，玩牌的人手里想拿多少张牌都可以，好刺激哦！\n刺激归刺激，但是拿多了怎么胡牌呢？\n超级麻将规定只要一个人手里拿的牌是若干句话（三个连续数字的牌各一张组成一句话，三张或者四张同样数字的牌也算一句话），再加上一对相同的牌，就算胡了。\n作为信息学竞赛选手的你，麻烦你给这位超级麻将迷编个程序，判断能否胡牌。\n\n## 输入格式\n\n输入文件第一行一个整数 $N(N\\le 100)$，表示玩了N次超级麻将。\n接下来N行，每行 $100$ 个数 $a_1 \\dots a_{100}$，描述每次玩牌手中各种牌的数量。$a_i$表示数字为i的牌有 $a_i$ 张。$(0\\le ai\\le 100)$\n\n## 输出格式\n\n输出 $N$ 行，若胡了则输出 `Yes`，否则输出 `No`，注意区分 `Yes`，`No` 的大小写！\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n3\n\n2 4 0 0 0 0 0 …… 0（一共98个0）\n\n2 4 2 0 0 0 0 …… 0（一共97个0）\n\n2 3 2 0 0 0 0 …… 0（一共97个0）\n```\n\n**输出：**\n```\nYes\n\nYes\n\nNo\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P2682 土豆田\n\n\n## 题目背景\n\n大宁在他家门口种了一大片土豆田，划分为 $n \\times m$ 的地块。\n大宁准备搭建学校的 OJ，为了测试土豆田的性能，大宁找到了你，为他的土豆编写代码。\n\n## 题目描述\n\n大宁的土豆田是以地块为单位的，每个地块里的所有土豆的集合称为一个处理单元，可以储存两个值：key（键值）和 tmp（缓存值），均为 $32$ 位带符号整数，每个单元。可以执行若干命令。大宁会骑着自行车轮流给每个处理单元供电，顺序如图，展示的是一个被分割为 $4\\times 4$ 处理单元的土豆田：\n\n单元的编号就是供电的顺序，每次按编号顺序从 $1$ 号到 $n\\times m$ 号遍历一遍。\n每一次完整的遍历称为一个周期。\n只有一块地上的土豆得到供电，它们才会工作，执行命令，所有命令执行完之后大宁会停止供电。\n对于每一个处理单元，命令格式如下：\n1. `in` 读取一个数，存放到该单元的 $\\text{tmp}$ 中。（如果 $\\text{tmp}$ 中有数，那么覆盖掉，以下的所有存放均如此）\n1. `out` 输出当前处理单元的 $\\text{key}$ 值。\n1. `swap` 交换该单元的 $\\text{key}$ 和 $\\text{tmp}$。\n1. `add X` 给 $\\text{key}$ 值加上 $X$，$X$ 只能是一个常数或者 $\\text{tmp}$，下同。\n1. `set X` 把 $\\text{key}$ 值修改为 $X$。\n1. `opp` 对 $\\text{key}$ 值取相反数。\n1. `rev` 对 $\\text{key}$ 值按位取反。\n1. `L/R X` 左/右移 $\\text{key}$ 值 $X$ 位。\n1. `get u/d/l/r` 将当前单元上(u)/下(d)/左(l)/右(r)面的单元的 $\\text{key}$ 值并把它复制到本单元的 $\\text{tmp}$，位置规则按照前面的图片所示。\n1. `or/and/or X` 对 $\\text{key}$ 值按位或/与/异或 $X$。\n1. `wait` 在本次供电的时间中等待，即什么事情也不做。\n1. `if X` 如果此时 X(只能是 $\\text{key}$ 或者 $\\text{tmp}$ )不等于 $0$ 则在下一次供电执行该语句的下一条语句，否则跳过下一条语句，执行下下条(如果存在的话)。\n1. `goto Y`  下一次供电从第 $Y$ 号命令开始执行，$Y$ 只能是常数。\n1. `end` 强制结束所有的处理单元的命令，无视所有尚未执行的命令。\n我们提供了 check.exe,把你的土豆程序 potato.out 和你想测试的输入数据 potato.in 放到与 check.exe 同文件夹下，运行之后可以在 report.txt 中查看你的程序的详细运行情况。\n我们还提供了另一个样例土豆程序 example2.out,使用 $2\\times2$ 处理单元的土豆程序，内容为计算一个整数 $a$ 的 $10$ 倍,可以自行解读（该样例并非该计算的最优解，只是为了展示命令）。\n下面展示了一个 $1 \\times 3$ 的处理单元，所有单元不一定需要全部使用。\n\n你有以下任务需要用编写土豆程序完成：\n|编号|输入|输出|数据范围|处理单元大小限制|分数|补充说明|\n| :----------: | :----------: | :----------:| :----------:| :----------:|:----------: | :----------: |\n|$1$|$a\\text{，}b$|$b-a$|$\\lvert a\\rvert \\text{，}\\lvert b\\rvert \\le10^9 $|$1 \\times 3$|$7$|无|\n|$2$|$a$|$233\\times a$|$1 \\le\\lvert a\\rvert \\le10^7 $|$2 \\times 2$|$9$|无|\n|$3$|$a$|$\\lvert a \\rvert$|$1 \\le\\lvert a\\rvert \\le10^9 $|$2 \\times 2$|$12$|求 $a$ 的绝对值|\n|$4$|$128$ 个整数 $a_i$|$\\sum^{128}_{i=1}a_i$|$1 \\le\\lvert a\\rvert \\le2 \\times 10^6 $|$4 \\times 2$|$12$|无|\n|$5$|$a\\text{，}b$|$\\lfloor \\frac{a+b}{2}\\rfloor$|$\\lvert a\\rvert \\text{，}\\lvert b\\rvert \\le2.1\\times10^9 $|$2 \\times 2$|$13$|无|\n|$6$|$a$|$\\operatorname{popcount}(a)$|$\\lvert a\\rvert\\le10^9 $|$2 \\times 2$|$13$|$\\operatorname{popcount}(a)$表示 $a$ 在二进制表示下 $1$ 的个数|\n|$7$|$a\\text{，}b$|$\\max {(a,b)}$|$\\lvert a\\rvert \\text{，}\\lvert b\\rvert \\le10^9 $|$2 \\times 2$|$14$|无|\n|$8$|$n$|$f(n)$|$1 \\le n \\le 42$|$3 \\times 3$|$20$|$f(n)=\\begin{cases}1 & n\n\n## 输入格式\n\n本题为提交答案题。\n\n## 输出格式\n\n第一行为 $n$ 和 $m$，表示你用了 $n$ 行 $m$ 列。\n接下来$n\\times m$个部分，第 $i$ 个部分的第一行 $t_i$ 表示在第 $i$ 个处理单元中命令的数量(可以为 $0$)，接下来 $t_i$ 行每行描述一个命令，见上文所述。\n\n## 说明/提示\n\n\n#### 样例#1解释\n\n这个样例实现了 A+B problem。\n第一行的 `1 1` 表示用的处理单元为 $1\\times1$。\n第二行表示第一个处理单元有 $5$ 条指令。\n第三行的命令在第一个周期执行，读入了一个数(假定为 $a$) ，此时该单元的状态为 $\\text{key}= 0 \\text{，}\\text{tmp}= a$。\n第四行在第二个周期执行，交换了 $\\text{key}$ 和 $\\text{tmp}$，状态为 $\\text{key}= a \\text{，}\\text{tmp}= 0$。\n第五行在第三个周期执行，读入了另一个数 $b$，状态为 $\\text{key}= a \\text{，}\\text{tmp}= b$。\n第六行在第四个周期执行，给 $\\text{key}$ 加上 $\\text{tmp}$，状态为 $\\text{key}= a+b \\text{，}\\text{tmp}= b$。\n第七行在第五个周期执行，输出该单元的 $\\text{key}$，即输出了 $a+b$。\n如果你的程序在 $2000$ 个周期内没有运行完毕，或者有语法错误，或者超过处理单元尺寸限制，得 $0$ 分。\n如果你的第 $i$ 个任务的程序能得出正确的结果，并且和标准答案运行所需的周期数量相同或比其更少，得会得到该测试点的满分，否则设你的程序运行了 $a$ 个周期，标准答案运行了 $s$ 个周期，你的分数为 $\\lfloor\\text{该测试点分数}\\times(\\frac{s}{a})\\times0.8 \\rfloor$(注意，部分正确显示WA,但是仍然有分数)。\n```cpp\nP1=7\nP2=9\nP3=12\nP4=12\nP5=13\nP6=13\nP7=14\nP8=20\n```\n\nPS:如果你构造了什么好玩的土豆程序(可以和本题目中的任务无关)，请到答疑博客下或者私信告诉我，会酌情给予奖励。\nCheck 下载见附件。\nexample2.out：\n```\n2 2 8 in add tmp\nL 3 get r add tmp\nget d add tmp\nout 3 wait get l add tmp\n3 wait get u add tmp\n```\n\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n例：一个使用1*1的土豆田处理单元(下称处理单元)的A+B problem\n输入两个整数a,b,|a|,|b|<=10^9\n输出a+b\n\n1 1\n5\nin\nswap\nin\nadd tmp\nout\n```\n\n**输出：**\n```\n解释：\n第一行的1 1表示用的处理单元为1*1\n第二行表示第一个处理单元有5条指令。\n第三行的命令在第一个周期执行，读入了一个数(假定为a) ，此时该单元的状态为key=0,tmp=a\n第四行在第二个周期执行，交换了key和tmp,状态为key=a,tmp=0\n第五行在第三个周期执行，读入了另一个数b，状态为key=a,tmp=b\n第六行在第四个周期执行，给key加上tmp，状态为key=a+b,tmp=b\n第七行在第五个周期执行，输出该单元的key，即输出了a+b\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P2682 土豆田\n\n\n## 题目背景\n\n大宁在他家门口种了一大片土豆田，划分为 $n \\times m$ 的地块。\n大宁准备搭建学校的 OJ，为了测试土豆田的性能，大宁找到了你，为他的土豆编写代码。\n\n## 题目描述\n\n大宁的土豆田是以地块为单位的，每个地块里的所有土豆的集合称为一个处理单元，可以储存两个值：key（键值）和 tmp（缓存值），均为 $32$ 位带符号整数，每个单元。可以执行若干命令。大宁会骑着自行车轮流给每个处理单元供电，顺序如图，展示的是一个被分割为 $4\\times 4$ 处理单元的土豆田：\n\n单元的编号就是供电的顺序，每次按编号顺序从 $1$ 号到 $n\\times m$ 号遍历一遍。\n每一次完整的遍历称为一个周期。\n只有一块地上的土豆得到供电，它们才会工作，执行命令，所有命令执行完之后大宁会停止供电。\n对于每一个处理单元，命令格式如下：\n1. `in` 读取一个数，存放到该单元的 $\\text{tmp}$ 中。（如果 $\\text{tmp}$ 中有数，那么覆盖掉，以下的所有存放均如此）\n1. `out` 输出当前处理单元的 $\\text{key}$ 值。\n1. `swap` 交换该单元的 $\\text{key}$ 和 $\\text{tmp}$。\n1. `add X` 给 $\\text{key}$ 值加上 $X$，$X$ 只能是一个常数或者 $\\text{tmp}$，下同。\n1. `set X` 把 $\\text{key}$ 值修改为 $X$。\n1. `opp` 对 $\\text{key}$ 值取相反数。\n1. `rev` 对 $\\text{key}$ 值按位取反。\n1. `L/R X` 左/右移 $\\text{key}$ 值 $X$ 位。\n1. `get u/d/l/r` 将当前单元上(u)/下(d)/左(l)/右(r)面的单元的 $\\text{key}$ 值并把它复制到本单元的 $\\text{tmp}$，位置规则按照前面的图片所示。\n1. `or/and/or X` 对 $\\text{key}$ 值按位或/与/异或 $X$。\n1. `wait` 在本次供电的时间中等待，即什么事情也不做。\n1. `if X` 如果此时 X(只能是 $\\text{key}$ 或者 $\\text{tmp}$ )不等于 $0$ 则在下一次供电执行该语句的下一条语句，否则跳过下一条语句，执行下下条(如果存在的话)。\n1. `goto Y`  下一次供电从第 $Y$ 号命令开始执行，$Y$ 只能是常数。\n1. `end` 强制结束所有的处理单元的命令，无视所有尚未执行的命令。\n我们提供了 check.exe,把你的土豆程序 potato.out 和你想测试的输入数据 potato.in 放到与 check.exe 同文件夹下，运行之后可以在 report.txt 中查看你的程序的详细运行情况。\n我们还提供了另一个样例土豆程序 example2.out,使用 $2\\times2$ 处理单元的土豆程序，内容为计算一个整数 $a$ 的 $10$ 倍,可以自行解读（该样例并非该计算的最优解，只是为了展示命令）。\n下面展示了一个 $1 \\times 3$ 的处理单元，所有单元不一定需要全部使用。\n\n你有以下任务需要用编写土豆程序完成：\n|编号|输入|输出|数据范围|处理单元大小限制|分数|补充说明|\n| :----------: | :----------: | :----------:| :----------:| :----------:|:----------: | :----------: |\n|$1$|$a\\text{，}b$|$b-a$|$\\lvert a\\rvert \\text{，}\\lvert b\\rvert \\le10^9 $|$1 \\times 3$|$7$|无|\n|$2$|$a$|$233\\times a$|$1 \\le\\lvert a\\rvert \\le10^7 $|$2 \\times 2$|$9$|无|\n|$3$|$a$|$\\lvert a \\rvert$|$1 \\le\\lvert a\\rvert \\le10^9 $|$2 \\times 2$|$12$|求 $a$ 的绝对值|\n|$4$|$128$ 个整数 $a_i$|$\\sum^{128}_{i=1}a_i$|$1 \\le\\lvert a\\rvert \\le2 \\times 10^6 $|$4 \\times 2$|$12$|无|\n|$5$|$a\\text{，}b$|$\\lfloor \\frac{a+b}{2}\\rfloor$|$\\lvert a\\rvert \\text{，}\\lvert b\\rvert \\le2.1\\times10^9 $|$2 \\times 2$|$13$|无|\n|$6$|$a$|$\\operatorname{popcount}(a)$|$\\lvert a\\rvert\\le10^9 $|$2 \\times 2$|$13$|$\\operatorname{popcount}(a)$表示 $a$ 在二进制表示下 $1$ 的个数|\n|$7$|$a\\text{，}b$|$\\max {(a,b)}$|$\\lvert a\\rvert \\text{，}\\lvert b\\rvert \\le10^9 $|$2 \\times 2$|$14$|无|\n|$8$|$n$|$f(n)$|$1 \\le n \\le 42$|$3 \\times 3$|$20$|$f(n)=\\begin{cases}1 & n\n\n## 输入格式\n\n本题为提交答案题。\n\n## 输出格式\n\n第一行为 $n$ 和 $m$，表示你用了 $n$ 行 $m$ 列。\n接下来$n\\times m$个部分，第 $i$ 个部分的第一行 $t_i$ 表示在第 $i$ 个处理单元中命令的数量(可以为 $0$)，接下来 $t_i$ 行每行描述一个命令，见上文所述。\n\n## 说明/提示\n\n\n#### 样例#1解释\n\n这个样例实现了 A+B problem。\n第一行的 `1 1` 表示用的处理单元为 $1\\times1$。\n第二行表示第一个处理单元有 $5$ 条指令。\n第三行的命令在第一个周期执行，读入了一个数(假定为 $a$) ，此时该单元的状态为 $\\text{key}= 0 \\text{，}\\text{tmp}= a$。\n第四行在第二个周期执行，交换了 $\\text{key}$ 和 $\\text{tmp}$，状态为 $\\text{key}= a \\text{，}\\text{tmp}= 0$。\n第五行在第三个周期执行，读入了另一个数 $b$，状态为 $\\text{key}= a \\text{，}\\text{tmp}= b$。\n第六行在第四个周期执行，给 $\\text{key}$ 加上 $\\text{tmp}$，状态为 $\\text{key}= a+b \\text{，}\\text{tmp}= b$。\n第七行在第五个周期执行，输出该单元的 $\\text{key}$，即输出了 $a+b$。\n如果你的程序在 $2000$ 个周期内没有运行完毕，或者有语法错误，或者超过处理单元尺寸限制，得 $0$ 分。\n如果你的第 $i$ 个任务的程序能得出正确的结果，并且和标准答案运行所需的周期数量相同或比其更少，得会得到该测试点的满分，否则设你的程序运行了 $a$ 个周期，标准答案运行了 $s$ 个周期，你的分数为 $\\lfloor\\text{该测试点分数}\\times(\\frac{s}{a})\\times0.8 \\rfloor$(注意，部分正确显示WA,但是仍然有分数)。\n```cpp\nP1=7\nP2=9\nP3=12\nP4=12\nP5=13\nP6=13\nP7=14\nP8=20\n```\n\nPS:如果你构造了什么好玩的土豆程序(可以和本题目中的任务无关)，请到答疑博客下或者私信告诉我，会酌情给予奖励。\nCheck 下载见附件。\nexample2.out：\n```\n2 2 8 in add tmp\nL 3 get r add tmp\nget d add tmp\nout 3 wait get l add tmp\n3 wait get u add tmp\n```\n\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n例：一个使用1*1的土豆田处理单元(下称处理单元)的A+B problem\n输入两个整数a,b,|a|,|b|<=10^9\n输出a+b\n\n1 1\n5\nin\nswap\nin\nadd tmp\nout\n```\n\n**输出：**\n```\n解释：\n第一行的1 1表示用的处理单元为1*1\n第二行表示第一个处理单元有5条指令。\n第三行的命令在第一个周期执行，读入了一个数(假定为a) ，此时该单元的状态为key=0,tmp=a\n第四行在第二个周期执行，交换了key和tmp,状态为key=a,tmp=0\n第五行在第三个周期执行，读入了另一个数b，状态为key=a,tmp=b\n第六行在第四个周期执行，给key加上tmp，状态为key=a+b,tmp=b\n第七行在第五个周期执行，输出该单元的key，即输出了a+b\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P2686 老虎的题目\n\n\n## 题目描述\n\n随着小老虎做题越来越多，现在可做小老师了，小老虎经常帮老师出题供信息学奥赛班的同学测试用。出题确实是一件麻烦事。现在有更麻烦的事了：\n小老虎收集到了一大堆的题目，并且按照收集的时间顺序排成一排。每个题目都有自己的题面长度和难度。小老虎想用这些题出好多好多场比赛。但是呢，有要求：\n- 同一场比赛的题目，必须是这一排题目中连续的一段，但题目数量不限。\n- 题面长度的总和，不能超过 $H$，也不能低于 $L$。\n- 不允许出现两场比赛，使得其中一场的题目全部在另一场出现过了。（也就是说，不同比赛的题目集合不能出现包含和被包含关系）\n题目可以在不同比赛中重复使用。\n现在，小老虎想知道，在满足以上条件的基础上，所有比赛的难度总和最大是多少？（定义一场比赛的难度为本场比赛出现的所有题目的难度和）\n\n## 输入格式\n\n第一行是三个整数，$N$、$L$、$H$。\n第二行有 $N$ 个整数，第 $i$ 个整数 $a_i$ 代表第 $i$ 题题面的长度。\n第三行有 $N$ 个整数，第 $i$ 个整数 $b_i$ 代表第 $i$ 题题目的难度。\n\n## 输出格式\n\n输出一个整数，所有比赛的最大难度总和。\n\n## 说明/提示\n\n对于 $40\\%$ 的数据，$1 \\le N \\le 100$。\n对于 $100\\%$ 的数据，$1 \\le N \\le 1000$，$0 \\le a_i,b_i \\le {10}^5$，答案不超过 $2^{31}-1$。\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n6 4 5\n1 3 3 2 2 1\n2 3 1 4 5 2\n```\n\n**输出：**\n```\n21\n\n注：样例中，3场，第一场选1，2两题，第二场选3，4两题，第三场选4，5，6三题。\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P2686 老虎的题目\n\n\n## 题目描述\n\n随着小老虎做题越来越多，现在可做小老师了，小老虎经常帮老师出题供信息学奥赛班的同学测试用。出题确实是一件麻烦事。现在有更麻烦的事了：\n小老虎收集到了一大堆的题目，并且按照收集的时间顺序排成一排。每个题目都有自己的题面长度和难度。小老虎想用这些题出好多好多场比赛。但是呢，有要求：\n- 同一场比赛的题目，必须是这一排题目中连续的一段，但题目数量不限。\n- 题面长度的总和，不能超过 $H$，也不能低于 $L$。\n- 不允许出现两场比赛，使得其中一场的题目全部在另一场出现过了。（也就是说，不同比赛的题目集合不能出现包含和被包含关系）\n题目可以在不同比赛中重复使用。\n现在，小老虎想知道，在满足以上条件的基础上，所有比赛的难度总和最大是多少？（定义一场比赛的难度为本场比赛出现的所有题目的难度和）\n\n## 输入格式\n\n第一行是三个整数，$N$、$L$、$H$。\n第二行有 $N$ 个整数，第 $i$ 个整数 $a_i$ 代表第 $i$ 题题面的长度。\n第三行有 $N$ 个整数，第 $i$ 个整数 $b_i$ 代表第 $i$ 题题目的难度。\n\n## 输出格式\n\n输出一个整数，所有比赛的最大难度总和。\n\n## 说明/提示\n\n对于 $40\\%$ 的数据，$1 \\le N \\le 100$。\n对于 $100\\%$ 的数据，$1 \\le N \\le 1000$，$0 \\le a_i,b_i \\le {10}^5$，答案不超过 $2^{31}-1$。\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n6 4 5\n1 3 3 2 2 1\n2 3 1 4 5 2\n```\n\n**输出：**\n```\n21\n\n注：样例中，3场，第一场选1，2两题，第二场选3，4两题，第三场选4，5，6三题。\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P2838 瓶子国的故事\n\n\n## 题目背景\n\n这是一道非传统题。\n传说有一个国家叫瓶子国，里面有大大小小的瓶子。\n现在瓶子国想要学习邻居跳蚤国发展计算机，可是瓶子国没有计算机只有瓶子。\n于是瓶子国国王就给了你一些瓶子，让你实现一些计算任务。\n\n## 题目描述\n\n我们用水的量来描述一个数。\n- 一个瓶子的容量为它最多可以装的水的数量。\n瓶子国国王认为瓶子可以干这些事：\n- $\\verb!I!$：制造一个新瓶子，它的容量和里面装的水量都为输入的数，这个瓶子的编号为 $\\textbf{当前最大编号} +1$。\n- $\\verb!F !s$；把编号为 $s$ 的瓶子里的水倒满。\n- $\\verb!E !s$：把编号为 $s$ 的瓶子里的水倒空。\n- $\\verb!C !s$：制作一个新瓶子，它的容量为 $s$，里面没装水，这个瓶子的编号为 $\\textbf{当前最大编号} +1$。注意由于瓶子容积有限，$0\\le s\\le 10^9$。\n- $\\verb!M !s$：制作一个新瓶子，它的容量为 $\\textbf{s 号瓶子里装的水的数量}$，里面没装水，这个瓶子的编号为 $\\textbf{当前最大编号}+1$。\n- $\\verb!T !a\\ b$：把 $a$ 瓶往 $b$ 瓶倒水，直到 $a$ 瓶空或者 $b$ 瓶满为止。（注意 $a\\neq b$）。\n- $\\verb!O !s$：把 $s$ 号瓶子里的水输出。\n还有一种昂贵的操作：\n- $\\verb!K !a\\ b$：制作一个新瓶子，它的容量为 $\\textbf{a 号瓶子的容量} \\times \\textbf{b 号瓶子的容量}$，这个瓶子的编号为 $\\textbf{当前最大编号}+1$。注意由于瓶子容积有限，$\\textbf{a 号瓶子的容量}\\times\\textbf{b 号瓶子的容量}$，不能超过 $10^9$。（使用这种操作要扣分，评分规则详见下方提示）\n现在瓶子国国王把这些操作给了你，你只要输出这些操作，瓶子国的瓶子们就会为你执行！\n瓶子国国王给了你一些计算任务，你只需要实现这些任务就行啦！\n左边是数据点编号，右边是计算任务。\n1. 输入 $a$ 和 $b$，计算 $a+b$。（$0\\le a,b\\le 10^5$）\n2. 输入 $a$ 和 $b$，计算 $|a-b|$。（$0\\le a,b\\le 10^5$）\n3. 输入 $a$ 和 $b$，计算 $\\max(a,b)$。（$0\\le a,b\\le 10^5$）\n4. 输入 $a$ 和 $b$，输出 $\\gcd(a,b)$。（$1\\le a,b\\le 1000$）\n5. 输入 $a$，输出 $a$ 的 $32$ 位二进制表示。（$0\\le a\\le 10^5$，例如 $5$ 输出 $\\verb!0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1!$）\n6. 输入 $a$ 和 $b$，输出 $a\\times b$。（$0\\le a,b\\le 1000$）\n7. 输入 $a$ 和 $b$，输出 $a\\oplus b$。（$0\\le a,b\\le 10^5$，$\\oplus$ 表示异或）\n8. 输入 $a$，输出 $a\\div 10$ 下取整。（$1\\le a\\le 10000$）\n9. 输入 $a$ 和 $b$，输出 $a\\times b \\bmod 262144$。（$0\\le a,b\\le 10^5$）\n10. 输入 $a$ 和 $b$，输出 $a$ 的 $b$ 次方。（$1\\le a,b\\le 1000$，$a$ 的 $b$ 次方不超过 $10^6$）\n瓶子国国王会生成 $30$ 组**左右**的数据对你的程序进行测试，并根据你使用的操作个数进行评分，评分规则详见下方提示。\n（**UPD**：如果你没有看懂题目这里有一段补充说明）\n你**提交到洛谷的程序**（C/C++/Pascal）需要输出一段操作，格式类似样例输出。\n例如第一个点，提交后洛谷上的 checker 会随机生成 $a$ 和 $b$ 作为 $\\verb!I!$ **操作的输入**来测试你的操作。\n对于本地 checker（下载见提示区），你可以把输出的操作保存成 `a.txt`，然后第一行输入 `a.txt`，第二行如果手玩就输 $0$，如果测试指定点就输编号。\n\n## 输入格式\n\n输入共一行一个整数，表示数据点编号。\n\n## 输出格式\n\n输出可以满足计算任务的操作。\n\n## 说明/提示\n\n请注意提交的是一段**输出操作的程序**！（如果你生成答案之后把生成它的程序删了直接打表输出，可能会输出超限）\n灵感来自 NOI2016 旷野大计算（其实我不说你们肯定也知道啊）\n为了方便选手本地测试，下面是一个 C++ 的本地checker（需要注意的是，它的测试结果与洛谷上的测试结果不一定一样，洛谷上可能更严格）：\n- http://paste.ubuntu.com/23070332/\n如果需要下载 exe 的话可戳度盘：\n- http://pan.baidu.com/s/1o7HZ1GY 密码为 `kqhl`。\n\n### 评分规则\n\n如果你的算法输出了错误结果（多输出也算）或者发生运行错误（操作不符合要求等）或者行数超过 $5\\times 10^6$ 行或者行数太长了 checker 没能在 $1s$ 内测试完 $30$ 组数据，你将获得 $0$ 分。\n否则，假设 std 的步数为 $s$，你的步数为 $x$。\n- 如果 $x\\le s$，你的基准分为 $10$ 分。\n- 如果 $s\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n233\n// 仅作为参考，这里应该填数据编号\n```\n\n**输出：**\n```\nI\nC 1\nF 2\nC 233333\nT 1 3\nT 2 3\nO 3\n（这个程序可以进行x+1！是不是很厉害啊！不过程序中并不能附加任何注释）\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P2838 瓶子国的故事\n\n\n## 题目背景\n\n这是一道非传统题。\n传说有一个国家叫瓶子国，里面有大大小小的瓶子。\n现在瓶子国想要学习邻居跳蚤国发展计算机，可是瓶子国没有计算机只有瓶子。\n于是瓶子国国王就给了你一些瓶子，让你实现一些计算任务。\n\n## 题目描述\n\n我们用水的量来描述一个数。\n- 一个瓶子的容量为它最多可以装的水的数量。\n瓶子国国王认为瓶子可以干这些事：\n- $\\verb!I!$：制造一个新瓶子，它的容量和里面装的水量都为输入的数，这个瓶子的编号为 $\\textbf{当前最大编号} +1$。\n- $\\verb!F !s$；把编号为 $s$ 的瓶子里的水倒满。\n- $\\verb!E !s$：把编号为 $s$ 的瓶子里的水倒空。\n- $\\verb!C !s$：制作一个新瓶子，它的容量为 $s$，里面没装水，这个瓶子的编号为 $\\textbf{当前最大编号} +1$。注意由于瓶子容积有限，$0\\le s\\le 10^9$。\n- $\\verb!M !s$：制作一个新瓶子，它的容量为 $\\textbf{s 号瓶子里装的水的数量}$，里面没装水，这个瓶子的编号为 $\\textbf{当前最大编号}+1$。\n- $\\verb!T !a\\ b$：把 $a$ 瓶往 $b$ 瓶倒水，直到 $a$ 瓶空或者 $b$ 瓶满为止。（注意 $a\\neq b$）。\n- $\\verb!O !s$：把 $s$ 号瓶子里的水输出。\n还有一种昂贵的操作：\n- $\\verb!K !a\\ b$：制作一个新瓶子，它的容量为 $\\textbf{a 号瓶子的容量} \\times \\textbf{b 号瓶子的容量}$，这个瓶子的编号为 $\\textbf{当前最大编号}+1$。注意由于瓶子容积有限，$\\textbf{a 号瓶子的容量}\\times\\textbf{b 号瓶子的容量}$，不能超过 $10^9$。（使用这种操作要扣分，评分规则详见下方提示）\n现在瓶子国国王把这些操作给了你，你只要输出这些操作，瓶子国的瓶子们就会为你执行！\n瓶子国国王给了你一些计算任务，你只需要实现这些任务就行啦！\n左边是数据点编号，右边是计算任务。\n1. 输入 $a$ 和 $b$，计算 $a+b$。（$0\\le a,b\\le 10^5$）\n2. 输入 $a$ 和 $b$，计算 $|a-b|$。（$0\\le a,b\\le 10^5$）\n3. 输入 $a$ 和 $b$，计算 $\\max(a,b)$。（$0\\le a,b\\le 10^5$）\n4. 输入 $a$ 和 $b$，输出 $\\gcd(a,b)$。（$1\\le a,b\\le 1000$）\n5. 输入 $a$，输出 $a$ 的 $32$ 位二进制表示。（$0\\le a\\le 10^5$，例如 $5$ 输出 $\\verb!0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1!$）\n6. 输入 $a$ 和 $b$，输出 $a\\times b$。（$0\\le a,b\\le 1000$）\n7. 输入 $a$ 和 $b$，输出 $a\\oplus b$。（$0\\le a,b\\le 10^5$，$\\oplus$ 表示异或）\n8. 输入 $a$，输出 $a\\div 10$ 下取整。（$1\\le a\\le 10000$）\n9. 输入 $a$ 和 $b$，输出 $a\\times b \\bmod 262144$。（$0\\le a,b\\le 10^5$）\n10. 输入 $a$ 和 $b$，输出 $a$ 的 $b$ 次方。（$1\\le a,b\\le 1000$，$a$ 的 $b$ 次方不超过 $10^6$）\n瓶子国国王会生成 $30$ 组**左右**的数据对你的程序进行测试，并根据你使用的操作个数进行评分，评分规则详见下方提示。\n（**UPD**：如果你没有看懂题目这里有一段补充说明）\n你**提交到洛谷的程序**（C/C++/Pascal）需要输出一段操作，格式类似样例输出。\n例如第一个点，提交后洛谷上的 checker 会随机生成 $a$ 和 $b$ 作为 $\\verb!I!$ **操作的输入**来测试你的操作。\n对于本地 checker（下载见提示区），你可以把输出的操作保存成 `a.txt`，然后第一行输入 `a.txt`，第二行如果手玩就输 $0$，如果测试指定点就输编号。\n\n## 输入格式\n\n输入共一行一个整数，表示数据点编号。\n\n## 输出格式\n\n输出可以满足计算任务的操作。\n\n## 说明/提示\n\n请注意提交的是一段**输出操作的程序**！（如果你生成答案之后把生成它的程序删了直接打表输出，可能会输出超限）\n灵感来自 NOI2016 旷野大计算（其实我不说你们肯定也知道啊）\n为了方便选手本地测试，下面是一个 C++ 的本地checker（需要注意的是，它的测试结果与洛谷上的测试结果不一定一样，洛谷上可能更严格）：\n- http://paste.ubuntu.com/23070332/\n如果需要下载 exe 的话可戳度盘：\n- http://pan.baidu.com/s/1o7HZ1GY 密码为 `kqhl`。\n\n### 评分规则\n\n如果你的算法输出了错误结果（多输出也算）或者发生运行错误（操作不符合要求等）或者行数超过 $5\\times 10^6$ 行或者行数太长了 checker 没能在 $1s$ 内测试完 $30$ 组数据，你将获得 $0$ 分。\n否则，假设 std 的步数为 $s$，你的步数为 $x$。\n- 如果 $x\\le s$，你的基准分为 $10$ 分。\n- 如果 $s\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n233\n// 仅作为参考，这里应该填数据编号\n```\n\n**输出：**\n```\nI\nC 1\nF 2\nC 233333\nT 1 3\nT 2 3\nO 3\n（这个程序可以进行x+1！是不是很厉害啊！不过程序中并不能附加任何注释）\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P3245 [HNOI2016] 大数\n\n\n## 题目描述\n\n小 B 有一个很大的数 $S$，长度达到了 $n$ 位；这个数可以看成是一个数字串，它可能有前导 $0$，例如 `00009312345`。小 B 还有一个素数 $p$。现在，小 B 提出了 $m$ 个询问，每个询问求 $S$ 的一个子串中有多少子串是 $p$ 的倍数（$0$ 也是 $p$ 的倍数）。例如 $S$ 为 `0077` 时，其子串 `007` 有 $6$ 个子串：`0,0,7,00,07,007`；显然 `0077` 的子串 `007` 有 $6$ 个子串都是素数 $7$ 的倍数。\n\n## 输入格式\n\n第一行一个整数：$p$。\n第二行一个数字串：$S$。\n第三行一个整数：$m$。接下来 $m$ 行，每行两个整数 $fr,to$，表示对 $S$ 的子串 $S[fr\\dots to]$ 的一次询问。注意：$S$ 的最左端的数字的位置序号为 $1$；例如 $S$ 为 `213567`，则 $S[1\\dots 3]$ 为 `213`。\n\n## 输出格式\n\n输出 $m$ 行，每行一个整数，第 $i$ 行是第 $i$ 个询问的答案。\n\n## 说明/提示\n\n\n#### 样例 1 解释\n\n第一个询问问的是整个串，满足条件的子串分别有：`121121,2112,11,121,121`。\n\n#### 数据范围\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 2\\times 10^5$，$2\\le p\\le 10^9$，$S$ 中只有数字字符，$p$ 为素数。\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n11\n121121\n3\n1 6\n1 5\n1 4\n```\n\n**输出：**\n```\n5\n\n3\n\n2\n\n//第一个询问问的是整个串，满足条件的子串分别有：121121,2112,11,121,121。\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P3245 [HNOI2016] 大数\n\n\n## 题目描述\n\n小 B 有一个很大的数 $S$，长度达到了 $n$ 位；这个数可以看成是一个数字串，它可能有前导 $0$，例如 `00009312345`。小 B 还有一个素数 $p$。现在，小 B 提出了 $m$ 个询问，每个询问求 $S$ 的一个子串中有多少子串是 $p$ 的倍数（$0$ 也是 $p$ 的倍数）。例如 $S$ 为 `0077` 时，其子串 `007` 有 $6$ 个子串：`0,0,7,00,07,007`；显然 `0077` 的子串 `007` 有 $6$ 个子串都是素数 $7$ 的倍数。\n\n## 输入格式\n\n第一行一个整数：$p$。\n第二行一个数字串：$S$。\n第三行一个整数：$m$。接下来 $m$ 行，每行两个整数 $fr,to$，表示对 $S$ 的子串 $S[fr\\dots to]$ 的一次询问。注意：$S$ 的最左端的数字的位置序号为 $1$；例如 $S$ 为 `213567`，则 $S[1\\dots 3]$ 为 `213`。\n\n## 输出格式\n\n输出 $m$ 行，每行一个整数，第 $i$ 行是第 $i$ 个询问的答案。\n\n## 说明/提示\n\n\n#### 样例 1 解释\n\n第一个询问问的是整个串，满足条件的子串分别有：`121121,2112,11,121,121`。\n\n#### 数据范围\n\n对于 $100\\%$ 的数据，$1\\le n,m\\le 2\\times 10^5$，$2\\le p\\le 10^9$，$S$ 中只有数字字符，$p$ 为素数。\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n11\n121121\n3\n1 6\n1 5\n1 4\n```\n\n**输出：**\n```\n5\n\n3\n\n2\n\n//第一个询问问的是整个串，满足条件的子串分别有：121121,2112,11,121,121。\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P3640 [APIO2013] 出题人\n\n\n## 题目描述\n\n当今世界上各类程序设计竞赛层出不穷。而设计一场好比赛绝非易事，比如给题目设计测试数据就是一项挑战。一组好的测试数据需要对不同的程序有区分度：满足所有要求的程序自然应该得到满分，而那些貌似正确的程序则会在某些特殊数据上出错。\n在本题中，你在比赛中的角色反转啦！作为一名久经百战的程序员，你将帮助 Happy Programmer Contest 的命题委员会设计这次比赛的测试数据。本次比赛命题委员会选择了两个图论问题，分为 $8$ 个子任务。委员会写了一些貌似可以解决这些子任务的代码。在给任务设计数据的时候，命题委员会期望其中的一些源程序能够得到满分，而另外的一些则只能得到 $0$ 分或者少许的部分分。现在你将会获得这些源程序（C, C++, Pascal 版本）。对于每个子任务，你需要去产生一组数据 $X$ 使得它能将该任务给定的 $2$ 种源程序 $A$ 和 $B$ 区分开来。更具体地说，生成的数据必须满足如下两个条件:\n输入 $X$ 对于源程序 $A$ 一定不会出现超出时间限制（TLE）的问题。\n输入 $X$ 一定会导致源程序 $B$ 产生超出时间限制的问题。\n此外,命题委员喜欢较小规模的测试数据，希望测试数据最好能够包含不超过 $T$ 个整数。\n本题中只关心源程序 $A$ 和 $B$ 是否超时，不关心是否结果正确。\n命题委员会选择了单源最短路（SSSP）以及一个被称之为神秘问题（Mystery）的两个图论问题来作为比赛的题目。我们将命题委员会完成的伪代码列在了附录中，而具体的 C、C++ 和 Pascal 源程序被我们放在了下发的文件当中。\n\n### 子任务\n\n参见下表。表中每一行描述了一个子任务。其中前六个子任务与单源最短路相关，子任务 7,8 与神秘问题相关。每个任务所占分数见下表。\n\n对于每个子任务，你的程序给出的输入 $X$ 需要能够将源程序 $A$ 和 $B$ 区分开来，这有这样你才能够得到相应的分数。具体说来，你的分数将由输入 $X$ 中数的个数决定。假设 $X$ 中包含了 $F$ 个整数，子任务的满分为 $S,T$ 是该任务的目标大小，则该测试点的分数将由下式给出:\n$$S \\times \\min\\{T / F, 1\\}$$\n也就是说，如果你的测试数据 $X$ 中含有不超过 $T$ 个整数，则你将得到该任务的全部得分。\n你需要把你的 $8$ 个测试数据命名为 `1.txt` ~ `8.txt`。对于每个子任务 $X$，评测系统将根据如下步骤来确定你将会得到多少分:\n- 如果未提交数据，则不得分；\n- 若数据不满足输入格式要求，则不得分；\n- 对源程序 $A$ 运行输入，若发生超时现象，则不得分；\n- 对源程序 $B$ 运行输入，若发生超时现象，则按照前文所述的公式给出该测试点的分数。\n题目提供的所有源代码均会维护一个计数器来统计程序的操作次数。在源程序的运行过程中，当该计数器超过了 $10^6$ 次时，那么我们认为程序运行超时。\n\n### 问题 1：单源最短路（SSSP）\n\n给定一个带权有向图 $G$，以及 $G$ 中的两个节点 $s$ 与 $t$，令 $p(s, t)$ 为 $G$ 中从 $s$ 至 $t$ 的最短路长度。如果 $s$ 与 $t$ 不连通，则认为 $p(s, t)=10^9$。在本题中，输入为图 $G$ 以及 $Q$ 个询问 $(s_1, t_1), (s_2, t_2), \\dots, (s_Q, t_Q)$ 。输出则是对这 $Q$ 个询问的相应输出 $p(s_1, t_1), p(s_2 , t_2), \\cdots, p(s_Q, t_Q)$。\n\n### 问题 2：神秘问题\n\n给定一个包含 $V$ 个节点 $E$ 条边的无向图 $G$，要求将所有的节点进行编号（编号范围为 $[0, X-1]$），使得所有直接相连的节点均有不同的编号。找出符合题意的最小的 $X$。\n\n## 输入格式\n\n\n### 问题 1\n\n输入数据包含两部分，其中第一部分使用邻接表来描述带权有向图 $G$。第二部分则描述对 $G$ 的最短路径的查询。\n数据第一部分的第一行包含一个整数 $V$，表示 $G$ 中点的个数，所有点的编号为 $0, 1, \\cdots, V - 1$。\n接下来 $V$ 行，每行描述一个点的所有边。行中的第一个整数 $n_i$ 描述了节点 $i$ 的出边数量，接下来有 $n_i$ 个整数对 $(j, w)$ 表示有一条从 $i$ 到 $j$，边权为 $w$ 的边。\n数据第二部分的第一行包含一个整数 $Q$，表示询问的组数。\n接下来 $Q$ 行，第 $k$ 行包含两个整数 $s_k, t_k$，为该询问对应的起点与终点位置。\n同一行中任意两个相邻的整数均需要至少一个空格将他们分开。除此之外，数据还需满足如下条件:\n- $0 < V \\leq 300$，$n_i$ 是一个非负整数，$0 \\leq j < V$，$\\lvert w \\rvert < 10^6$，$0 \\leq \\sum\\limits_{i = 0}^{V-1} n_i \\leq 5000$，$0 < Q \\leq 10$，$0 \\leq s_k < V, 0 \\leq t_k < V$；\n- 图中没有负权圈。\n\n### 问题 2\n\n输入数据的第一行包含两个整数 $V$ 和 $E$。\n接下来 $E$ 行,每行两个整数 $a, b$，表示 $a$ 与 $b$ 在 $G$ 中直接相连。此外,输入数据应满足如下限制条件:\n- $70 < V < 1000$，$1500 < E < 10^6$；\n- 对于所有的边 $(a, b)$，有 $a \\neq b, 0 \\leq a < V, 0 \\leq b < V$，不会重复描述一条边。\n\n## 输出格式\n\n\n### 问题 1\n\n程序将会输出 $Q$ 行，每行一个整数，表示对应的 $p(s_k , t_k)$。而在输出的最后，所有提供的程序都会给出计数器对此输入的数值。\n\n### 问题 2\n\n程序将在第一行输出 $X$，即最小的编号范围，接下来在第二行中给出 $V$ 个整数，依次描述节点 $0$ 至 $V - 1$ 的编号。在输出的最后，所有提供的程序都会给出计数器对此输入的数值。\n\n## 说明/提示\n\n**源代码见附件**。\n\n### 附录：伪代码\n\n接下来是我们提供的所有程序的伪代码；变量 counter 近似描述出了程序的运行时间。评测时将会使用这些伪代码的 C++ 版本来进行评测。\nFloydWarshall\n```cpp\n// pre-condition: the graph is stored in an adjacency matrix M\ncounter = 0\nfor k = 0 to V-1\nfor i = 0 to V-1\nfor j = 0 to V-1\nincrease counter by 1;\nM[i][j] = min(M[i][j], M[i][k] + M[k][j]);\nfor each query p(s,t)\noutput M[s][t];\n```\n\nOptimizedBellmanFord\n```cpp\n// pre-condition: the graph is stored in an adjacency list L\ncounter = 0\nfor each query p(s,t);\ndist[s] = 0; // s is the source vertex\nloop V-1 times\nchange = false;\nfor each edge (u,v) in L\nincrease counter by 1;\nif dist[u] + weight(u,v) < dist[v]\ndist[v] = dist[u] + weight(u,v);\nchange = true;\nif change is false // this is the ’optimized’ Bellman Ford\nbreak from the outermost loop;\noutput dist[t];\n```\n\nModifiedDijkstra\n```cpp\n// pre-condition: the graph is stored in an adjacency list L\ncounter = 0;\nfor each query p(s,t)\ndist[s] = 0;\npq.push(pair(0, s)); // pq is a priority queue\nwhile pq is not empty\nincrease counter by 1;\n(d, u) = the top element of pq;\nremove the top element from pq;\nif (d == dist[u])\nfor each edge (u,v) in L\nif (dist[u] + weight(u,v) ) < dist[v]\ndist[v] = dist[u] + weight(u,v);\ninsert pair (dist[v], v) into the pq;\noutput dist[t];\n```\n\nGamble1\n```cpp\nSets X = V;\nlabels vertex i in [0..V-1] with i;\nSets counter = 0; // will never get TLE\n```\n\nGamble2\n```cpp\nSets X = V;\nlabels vertex i in [0..V-1] with i;\nSets counter = 1000001; // force this to get TLE\n```\n\nRecursiveBacktracking\n```cpp\nThis algorithm tries X from 2 to V one by one and stops at the first valid X.\nFor each X, the backtracking routine label vertex 0 with 0, then for each vertex u that has been assigned a label, the backtracking routine tries to assign\nthe smallest possible label up to label X-1 to its neighbor v, and backtracks if necessary.\n// Please check RecursiveBacktracking.cpp/pas to see\n// the exact lines where the iteration counter is increased by 1\n```\n\n感谢zhouyonglong修改spj\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n3\n2 1 4 2 1\n0\n1 1 2\n2\n0 1\n1 0\n//以上为问题1\n```\n\n**输出：**\n```\n3\n1000000000\nThe value of counter is: 5\n```\n\n### 样例 2\n\n**输入：**\n```\n4 5\n0 1\n0 2\n0 3\n1 2\n2 3\n//以上为问题2\n```\n\n**输出：**\n```\n3\n0 1 2 1\nThe value of counter is: 18\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P3640 [APIO2013] 出题人\n\n\n## 题目描述\n\n当今世界上各类程序设计竞赛层出不穷。而设计一场好比赛绝非易事，比如给题目设计测试数据就是一项挑战。一组好的测试数据需要对不同的程序有区分度：满足所有要求的程序自然应该得到满分，而那些貌似正确的程序则会在某些特殊数据上出错。\n在本题中，你在比赛中的角色反转啦！作为一名久经百战的程序员，你将帮助 Happy Programmer Contest 的命题委员会设计这次比赛的测试数据。本次比赛命题委员会选择了两个图论问题，分为 $8$ 个子任务。委员会写了一些貌似可以解决这些子任务的代码。在给任务设计数据的时候，命题委员会期望其中的一些源程序能够得到满分，而另外的一些则只能得到 $0$ 分或者少许的部分分。现在你将会获得这些源程序（C, C++, Pascal 版本）。对于每个子任务，你需要去产生一组数据 $X$ 使得它能将该任务给定的 $2$ 种源程序 $A$ 和 $B$ 区分开来。更具体地说，生成的数据必须满足如下两个条件:\n输入 $X$ 对于源程序 $A$ 一定不会出现超出时间限制（TLE）的问题。\n输入 $X$ 一定会导致源程序 $B$ 产生超出时间限制的问题。\n此外,命题委员喜欢较小规模的测试数据，希望测试数据最好能够包含不超过 $T$ 个整数。\n本题中只关心源程序 $A$ 和 $B$ 是否超时，不关心是否结果正确。\n命题委员会选择了单源最短路（SSSP）以及一个被称之为神秘问题（Mystery）的两个图论问题来作为比赛的题目。我们将命题委员会完成的伪代码列在了附录中，而具体的 C、C++ 和 Pascal 源程序被我们放在了下发的文件当中。\n\n### 子任务\n\n参见下表。表中每一行描述了一个子任务。其中前六个子任务与单源最短路相关，子任务 7,8 与神秘问题相关。每个任务所占分数见下表。\n\n对于每个子任务，你的程序给出的输入 $X$ 需要能够将源程序 $A$ 和 $B$ 区分开来，这有这样你才能够得到相应的分数。具体说来，你的分数将由输入 $X$ 中数的个数决定。假设 $X$ 中包含了 $F$ 个整数，子任务的满分为 $S,T$ 是该任务的目标大小，则该测试点的分数将由下式给出:\n$$S \\times \\min\\{T / F, 1\\}$$\n也就是说，如果你的测试数据 $X$ 中含有不超过 $T$ 个整数，则你将得到该任务的全部得分。\n你需要把你的 $8$ 个测试数据命名为 `1.txt` ~ `8.txt`。对于每个子任务 $X$，评测系统将根据如下步骤来确定你将会得到多少分:\n- 如果未提交数据，则不得分；\n- 若数据不满足输入格式要求，则不得分；\n- 对源程序 $A$ 运行输入，若发生超时现象，则不得分；\n- 对源程序 $B$ 运行输入，若发生超时现象，则按照前文所述的公式给出该测试点的分数。\n题目提供的所有源代码均会维护一个计数器来统计程序的操作次数。在源程序的运行过程中，当该计数器超过了 $10^6$ 次时，那么我们认为程序运行超时。\n\n### 问题 1：单源最短路（SSSP）\n\n给定一个带权有向图 $G$，以及 $G$ 中的两个节点 $s$ 与 $t$，令 $p(s, t)$ 为 $G$ 中从 $s$ 至 $t$ 的最短路长度。如果 $s$ 与 $t$ 不连通，则认为 $p(s, t)=10^9$。在本题中，输入为图 $G$ 以及 $Q$ 个询问 $(s_1, t_1), (s_2, t_2), \\dots, (s_Q, t_Q)$ 。输出则是对这 $Q$ 个询问的相应输出 $p(s_1, t_1), p(s_2 , t_2), \\cdots, p(s_Q, t_Q)$。\n\n### 问题 2：神秘问题\n\n给定一个包含 $V$ 个节点 $E$ 条边的无向图 $G$，要求将所有的节点进行编号（编号范围为 $[0, X-1]$），使得所有直接相连的节点均有不同的编号。找出符合题意的最小的 $X$。\n\n## 输入格式\n\n\n### 问题 1\n\n输入数据包含两部分，其中第一部分使用邻接表来描述带权有向图 $G$。第二部分则描述对 $G$ 的最短路径的查询。\n数据第一部分的第一行包含一个整数 $V$，表示 $G$ 中点的个数，所有点的编号为 $0, 1, \\cdots, V - 1$。\n接下来 $V$ 行，每行描述一个点的所有边。行中的第一个整数 $n_i$ 描述了节点 $i$ 的出边数量，接下来有 $n_i$ 个整数对 $(j, w)$ 表示有一条从 $i$ 到 $j$，边权为 $w$ 的边。\n数据第二部分的第一行包含一个整数 $Q$，表示询问的组数。\n接下来 $Q$ 行，第 $k$ 行包含两个整数 $s_k, t_k$，为该询问对应的起点与终点位置。\n同一行中任意两个相邻的整数均需要至少一个空格将他们分开。除此之外，数据还需满足如下条件:\n- $0 < V \\leq 300$，$n_i$ 是一个非负整数，$0 \\leq j < V$，$\\lvert w \\rvert < 10^6$，$0 \\leq \\sum\\limits_{i = 0}^{V-1} n_i \\leq 5000$，$0 < Q \\leq 10$，$0 \\leq s_k < V, 0 \\leq t_k < V$；\n- 图中没有负权圈。\n\n### 问题 2\n\n输入数据的第一行包含两个整数 $V$ 和 $E$。\n接下来 $E$ 行,每行两个整数 $a, b$，表示 $a$ 与 $b$ 在 $G$ 中直接相连。此外,输入数据应满足如下限制条件:\n- $70 < V < 1000$，$1500 < E < 10^6$；\n- 对于所有的边 $(a, b)$，有 $a \\neq b, 0 \\leq a < V, 0 \\leq b < V$，不会重复描述一条边。\n\n## 输出格式\n\n\n### 问题 1\n\n程序将会输出 $Q$ 行，每行一个整数，表示对应的 $p(s_k , t_k)$。而在输出的最后，所有提供的程序都会给出计数器对此输入的数值。\n\n### 问题 2\n\n程序将在第一行输出 $X$，即最小的编号范围，接下来在第二行中给出 $V$ 个整数，依次描述节点 $0$ 至 $V - 1$ 的编号。在输出的最后，所有提供的程序都会给出计数器对此输入的数值。\n\n## 说明/提示\n\n**源代码见附件**。\n\n### 附录：伪代码\n\n接下来是我们提供的所有程序的伪代码；变量 counter 近似描述出了程序的运行时间。评测时将会使用这些伪代码的 C++ 版本来进行评测。\nFloydWarshall\n```cpp\n// pre-condition: the graph is stored in an adjacency matrix M\ncounter = 0\nfor k = 0 to V-1\nfor i = 0 to V-1\nfor j = 0 to V-1\nincrease counter by 1;\nM[i][j] = min(M[i][j], M[i][k] + M[k][j]);\nfor each query p(s,t)\noutput M[s][t];\n```\n\nOptimizedBellmanFord\n```cpp\n// pre-condition: the graph is stored in an adjacency list L\ncounter = 0\nfor each query p(s,t);\ndist[s] = 0; // s is the source vertex\nloop V-1 times\nchange = false;\nfor each edge (u,v) in L\nincrease counter by 1;\nif dist[u] + weight(u,v) < dist[v]\ndist[v] = dist[u] + weight(u,v);\nchange = true;\nif change is false // this is the ’optimized’ Bellman Ford\nbreak from the outermost loop;\noutput dist[t];\n```\n\nModifiedDijkstra\n```cpp\n// pre-condition: the graph is stored in an adjacency list L\ncounter = 0;\nfor each query p(s,t)\ndist[s] = 0;\npq.push(pair(0, s)); // pq is a priority queue\nwhile pq is not empty\nincrease counter by 1;\n(d, u) = the top element of pq;\nremove the top element from pq;\nif (d == dist[u])\nfor each edge (u,v) in L\nif (dist[u] + weight(u,v) ) < dist[v]\ndist[v] = dist[u] + weight(u,v);\ninsert pair (dist[v], v) into the pq;\noutput dist[t];\n```\n\nGamble1\n```cpp\nSets X = V;\nlabels vertex i in [0..V-1] with i;\nSets counter = 0; // will never get TLE\n```\n\nGamble2\n```cpp\nSets X = V;\nlabels vertex i in [0..V-1] with i;\nSets counter = 1000001; // force this to get TLE\n```\n\nRecursiveBacktracking\n```cpp\nThis algorithm tries X from 2 to V one by one and stops at the first valid X.\nFor each X, the backtracking routine label vertex 0 with 0, then for each vertex u that has been assigned a label, the backtracking routine tries to assign\nthe smallest possible label up to label X-1 to its neighbor v, and backtracks if necessary.\n// Please check RecursiveBacktracking.cpp/pas to see\n// the exact lines where the iteration counter is increased by 1\n```\n\n感谢zhouyonglong修改spj\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n3\n2 1 4 2 1\n0\n1 1 2\n2\n0 1\n1 0\n//以上为问题1\n```\n\n**输出：**\n```\n3\n1000000000\nThe value of counter is: 5\n```\n\n### 样例 2\n\n**输入：**\n```\n4 5\n0 1\n0 2\n0 3\n1 2\n2 3\n//以上为问题2\n```\n\n**输出：**\n```\n3\n0 1 2 1\nThe value of counter is: 18\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P3641 [APIO2016] 最大差分\n\n\n## 题目背景\n\n\n## 评测方式\n\n以下是本题评测方式，与题面不符时以这里为准。\n你的代码中不应该包含 `gap.h` 库。\n你的代码中需如下进行 `findGap` 和 `MinMax` 函数的声明：\n```cpp\nextern \"C\" void MinMax(long long,long long,long long*,long long*);\nextern \"C\" long long findGap(int,int);\n```\n\nspj 与交互库\n不保证没锅，要是有锅请私信供题人然后 D 死他。\n\n## 题目描述\n\n有 $N$ 个严格递增的非负整数 $a_1, a_2, \\dots, a_N$（$0 \\leq a_1 < a_2 < \\cdots < a_N \\leq 10^{18}$）。你需要找出 $a_{i + 1} - a_i$（$1 \\leq i \\leq N - 1$）里的最大的值。\n你的程序不能直接读入这个整数序列，但是你可以通过给定的函数来查询该序列的信息。关于查询函数的细节，请根据你所使用的语言，参考下面的实现细节部分。\n你需要实现一个函数,该函数返回 $a_{i + 1} - a_i$（$1 \\leq i \\leq N - 1$）中的最大值。\n\n## 实现细节\n\n**本题只支持 C++（包括 cpp11，cpp14，cpp17）**。\n\n### C/C++\n\n你需要包含头文件 `gap.h`。\n你需要实现一个函数 `findGap(T, N)`，该函数接受下面的参数，并返回一个 `long long` 类型的整数：\n- $T$：子任务的编号（$1$ 或者 $2$）\n- $N$：序列的长度\n你的函数 `findGap` 可以调用系统提供的查询函数 `MinMax(s, t, &mn, &mx)`，该函数的前两个参数 $s$ 和 $t$ 是 `long long` 类型的整数，后两个参数 `&mn` 和 `&mx` 是 `long long` 类型的整数的指针（`mn` 和 `mx` 是 `long long` 类型的整数）。当 `MinMax(s, t, &mn, &mx)` 返回时，变量 `mn` 将会存储满足 $a_i \\in [s, t]$ 中 $a_i$ 的最小值，变量 `mx` 将会存储满足 $a_i \\in [s, t]$，$a_i$ 的最大值。如果区间 $[s, t]$ 中没有序列中的数，则 `mn` 和 `mx` 都将存储 $-1$。在查询时需要满足 $s \\leq t$，否则程序将会终止，该测试点计为 $0$ 分。\n\n### Pascal\n\n你需要使用单元 `graderhelperlib`。\n你需要实现一个函数 `findGap(T, N)`，该函数接受下面的参数，并返回一个 `Int64` 类型的整数：\n- $T$：子任务的编号（$1$ 或者 $2$）（`Integer` 类型）\n- $N$：序列的长度（`LongInt` 类型）\n你的函数 `findGap` 可以调用系统提供的查询函数 `MinMax(s, t, mn, mx)`，该函数的前两个参数 $s$ 和 $t$ 是 `Int64` 类型的整数，后两个参数 `mn` 和 `mx` 是传引用方式的 `Int64` 类型的整数（过程内部对这两个变量的修改会影响到外部的对应变量的值）。当 `MinMax(s, t, mn, mx)` 执行完毕时，变量 `mn` 将会存储满足 $a_i \\in [s, t]$ 中 $a_i$ 的最小值，变量 `mx` 将会存储满足 $a_i \\in [s, t]$，$a_i$ 的最大值。如果区间 $[s, t]$ 中没有序列中的数，则 `mn` 和 `mx` 都将存储 $-1$。在查询时需要满足 $s \\leq t$，否则程序将会终止，该测试点计为 $0$ 分。\n\n## 输入格式\n\n\n## 样例一\n\n\n### C/C++\n\n考虑 $N = 4, a_1 = 2, a_2 = 3, a_3 = 6, a_4 = 8$。\n则答案应该是 $3$，可以通过下面的几组对 `MinMax` 的询问获得：\n调用 `MinMax(1, 2, &mn, &mx)`，则 `mn` 和 `mx` 皆返回 $2$。\n调用 `MinMax(3, 7, &mn, &mx)`，则 `mn` 返回 $3$，`mx` 返回 $6$。\n调用 `MinMax(8, 9, &mn, &mx)`，则 `mn` 和 `mx` 皆返回 $8$。\n\n### Pascal\n\n考虑 $N = 4, a_1 = 2, a_2 = 3, a_3 = 6, a_4 = 8$。\n则答案应该是 $3$，可以通过下面的几组对 `MinMax` 的询问获得：\n调用 `MinMax(1, 2, mn, mx)`，则 `mn` 和 `mx` 皆返回 $2$。\n调用 `MinMax(3, 7, mn, mx)`，则 `mn` 返回 $3$，`mx` 返回 $6$。\n调用 `MinMax(8, 9, mn, mx)`，则 `mn` 和 `mx` 皆返回 $8$。\n\n## 样例评测方式\n\n样例测评系统从标准输入中读入两行。第一行包含两个整数，子任务编号 $T$，和序列长度 $N$。第二行包含 $N$ 个严格递增的非负整数。然后该程序会向标准输出中写入两行，第一行为 `findGap` 的返回值，第二行为花费 $M$ 的值。\n下面的输入描述了上面的样例：\n```plane\n2 4\n2 3 6 8\n```\n\n注意实际使用的交互库和 spj 对数据进行了加密。\n\n## 输出格式\n\n*无*\n\n## 说明/提示\n\n\n## 限制与约定\n\n对于所有的测试点，有 $2 \\leq N \\leq 100000$。\n每一个测试点开始测试之前，$M$ 都将被初始化为 $0$。\n子任务 1（$30$ 分）：每一次调用 `MinMax` 都将使 $M$ 加 $1$。为了获得所有分数，需要满足对于该子任务下的所有测试点，都有 $M \\leq \\frac{N + 1}{2}$。\n子任务 2（$70$ 分）：定义 $k$ 为调用 `MinMax` 时，区间 $[s, t]$ 中的序列中数的数量。每次调用 `MinMax`，将使 $M$ 加上 $k + 1$。对于每一个测试点，如果 $M \\leq 3N$，你将得到 70 分，否则将得到 $\\dfrac{60}{\\sqrt{\\frac MN + 1} - 1}$ 分。你的该子任务的得分是其下所有测试点中的最低分。", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P3641 [APIO2016] 最大差分\n\n\n## 题目背景\n\n\n## 评测方式\n\n以下是本题评测方式，与题面不符时以这里为准。\n你的代码中不应该包含 `gap.h` 库。\n你的代码中需如下进行 `findGap` 和 `MinMax` 函数的声明：\n```cpp\nextern \"C\" void MinMax(long long,long long,long long*,long long*);\nextern \"C\" long long findGap(int,int);\n```\n\nspj 与交互库\n不保证没锅，要是有锅请私信供题人然后 D 死他。\n\n## 题目描述\n\n有 $N$ 个严格递增的非负整数 $a_1, a_2, \\dots, a_N$（$0 \\leq a_1 < a_2 < \\cdots < a_N \\leq 10^{18}$）。你需要找出 $a_{i + 1} - a_i$（$1 \\leq i \\leq N - 1$）里的最大的值。\n你的程序不能直接读入这个整数序列，但是你可以通过给定的函数来查询该序列的信息。关于查询函数的细节，请根据你所使用的语言，参考下面的实现细节部分。\n你需要实现一个函数,该函数返回 $a_{i + 1} - a_i$（$1 \\leq i \\leq N - 1$）中的最大值。\n\n## 实现细节\n\n**本题只支持 C++（包括 cpp11，cpp14，cpp17）**。\n\n### C/C++\n\n你需要包含头文件 `gap.h`。\n你需要实现一个函数 `findGap(T, N)`，该函数接受下面的参数，并返回一个 `long long` 类型的整数：\n- $T$：子任务的编号（$1$ 或者 $2$）\n- $N$：序列的长度\n你的函数 `findGap` 可以调用系统提供的查询函数 `MinMax(s, t, &mn, &mx)`，该函数的前两个参数 $s$ 和 $t$ 是 `long long` 类型的整数，后两个参数 `&mn` 和 `&mx` 是 `long long` 类型的整数的指针（`mn` 和 `mx` 是 `long long` 类型的整数）。当 `MinMax(s, t, &mn, &mx)` 返回时，变量 `mn` 将会存储满足 $a_i \\in [s, t]$ 中 $a_i$ 的最小值，变量 `mx` 将会存储满足 $a_i \\in [s, t]$，$a_i$ 的最大值。如果区间 $[s, t]$ 中没有序列中的数，则 `mn` 和 `mx` 都将存储 $-1$。在查询时需要满足 $s \\leq t$，否则程序将会终止，该测试点计为 $0$ 分。\n\n### Pascal\n\n你需要使用单元 `graderhelperlib`。\n你需要实现一个函数 `findGap(T, N)`，该函数接受下面的参数，并返回一个 `Int64` 类型的整数：\n- $T$：子任务的编号（$1$ 或者 $2$）（`Integer` 类型）\n- $N$：序列的长度（`LongInt` 类型）\n你的函数 `findGap` 可以调用系统提供的查询函数 `MinMax(s, t, mn, mx)`，该函数的前两个参数 $s$ 和 $t$ 是 `Int64` 类型的整数，后两个参数 `mn` 和 `mx` 是传引用方式的 `Int64` 类型的整数（过程内部对这两个变量的修改会影响到外部的对应变量的值）。当 `MinMax(s, t, mn, mx)` 执行完毕时，变量 `mn` 将会存储满足 $a_i \\in [s, t]$ 中 $a_i$ 的最小值，变量 `mx` 将会存储满足 $a_i \\in [s, t]$，$a_i$ 的最大值。如果区间 $[s, t]$ 中没有序列中的数，则 `mn` 和 `mx` 都将存储 $-1$。在查询时需要满足 $s \\leq t$，否则程序将会终止，该测试点计为 $0$ 分。\n\n## 输入格式\n\n\n## 样例一\n\n\n### C/C++\n\n考虑 $N = 4, a_1 = 2, a_2 = 3, a_3 = 6, a_4 = 8$。\n则答案应该是 $3$，可以通过下面的几组对 `MinMax` 的询问获得：\n调用 `MinMax(1, 2, &mn, &mx)`，则 `mn` 和 `mx` 皆返回 $2$。\n调用 `MinMax(3, 7, &mn, &mx)`，则 `mn` 返回 $3$，`mx` 返回 $6$。\n调用 `MinMax(8, 9, &mn, &mx)`，则 `mn` 和 `mx` 皆返回 $8$。\n\n### Pascal\n\n考虑 $N = 4, a_1 = 2, a_2 = 3, a_3 = 6, a_4 = 8$。\n则答案应该是 $3$，可以通过下面的几组对 `MinMax` 的询问获得：\n调用 `MinMax(1, 2, mn, mx)`，则 `mn` 和 `mx` 皆返回 $2$。\n调用 `MinMax(3, 7, mn, mx)`，则 `mn` 返回 $3$，`mx` 返回 $6$。\n调用 `MinMax(8, 9, mn, mx)`，则 `mn` 和 `mx` 皆返回 $8$。\n\n## 样例评测方式\n\n样例测评系统从标准输入中读入两行。第一行包含两个整数，子任务编号 $T$，和序列长度 $N$。第二行包含 $N$ 个严格递增的非负整数。然后该程序会向标准输出中写入两行，第一行为 `findGap` 的返回值，第二行为花费 $M$ 的值。\n下面的输入描述了上面的样例：\n```plane\n2 4\n2 3 6 8\n```\n\n注意实际使用的交互库和 spj 对数据进行了加密。\n\n## 输出格式\n\n*无*\n\n## 说明/提示\n\n\n## 限制与约定\n\n对于所有的测试点，有 $2 \\leq N \\leq 100000$。\n每一个测试点开始测试之前，$M$ 都将被初始化为 $0$。\n子任务 1（$30$ 分）：每一次调用 `MinMax` 都将使 $M$ 加 $1$。为了获得所有分数，需要满足对于该子任务下的所有测试点，都有 $M \\leq \\frac{N + 1}{2}$。\n子任务 2（$70$ 分）：定义 $k$ 为调用 `MinMax` 时，区间 $[s, t]$ 中的序列中数的数量。每次调用 `MinMax`，将使 $M$ 加上 $k + 1$。对于每一个测试点，如果 $M \\leq 3N$，你将得到 70 分，否则将得到 $\\dfrac{60}{\\sqrt{\\frac MN + 1} - 1}$ 分。你的该子任务的得分是其下所有测试点中的最低分。", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P3777 [APIO2017] 考拉的游戏\n\n\n## 题目背景\n\n\n### 特别提示\n\n**在洛谷提交本题时的一些注意事项（与原题面不同之处请以此处为准）：**\n1. 提交时请在程序里加入以下函数声明语句：\n```cpp\nvoid playRound(int*,int*);\n```\n\n2. 程序开头不用，也不应该包含 `koala.h` 头文件。\n3. 仅支持 `C++`（含 `C++`，`C++11`，`C++14`，`C++17`）提交。\n\n## 题目描述\n\nKoala 发明了一个新游戏，来邀请你一起玩！游戏的开始，她会在桌上放 $N$ 个物品，物品从 $0$ 到 $N - 1$ 标号。接着，她会秘密地给每个物品分配一个 $1$ 到 $N$ 之间的整数权值，且任意两个物品不会被分配到相同的权值。其中，第 $i$ 个物品的权值为 $P_i$。她请你来确定由这些权值构成的序列 $P=P_0,P_1,\\dots ,P_{N-1}$ 的一些特征。\n为了回答她的问题，你可以请 Koala 玩若干轮游戏。每一轮中，你会得到 $W$ 个蓝色石子，Koala 会得到 $W$ 个红色石子。首先，你可以选择若干个物品，再把你的一些（或全部）石子放在这些物品的旁边。Koala 会观察你的石子分配，然后类似地把她的一些（或全部）石子放在若干个物品旁边。如果一个物品旁边的红色石子数严格大于蓝色石子数，那么，Koala可以获得这个物品。Koala 分配她的石子时，总会选择使她获得的物品的权值和最大的方案，如果有多种方案可以做到这一点，她会选择一种获得的物品数最多的方案，如果仍然有多种方案，她会选择其中任意一种。\nKoala 非常懒，如果你和她玩太多轮游戏，她就会睡着。你的任务是通过尽可能少轮数的游戏，确定 Koala 的序列 $P$ 的相关特征。\n\n### 任务\n\n在这个任务中，你需要实现 $4$ 个函数：`minValue`, `maxValue`, `greaterValue` 和 `allValues`。\n每个函数需要你确定序列 $P$ 的不同特征。我们强烈推荐在我们提供的模版的基础上进行作答。注意，即使你只想获得部分子任务的分数，你也必须为四个函数都提供一个实现（尽管一些函数的内部可能为空）。你的程序禁止从标准输入读数据、向标准输出写数据或与任何文件交互。\n在每个函数中，参数 `N` 表示游戏中物品的个数，参数 `W` 表示你和 Koala 在每一轮游戏中拥有的石子数。\n* `minValue(N, W)` --- 这个函数需要返回权值最小的物品的标号 $i$，即 $P_i=1$\n* `maxValue(N, W)` --- 这个函数需要返回权值最大的物品的标号 $i$，即 $P_i=N$\n* `greaterValue(N, W)` --- 这个函数需要比较物品 $0$ 和物品 $1$ 的权值，返回权值较大的物品的标号。具体来说，若 $P_0>P_1$​，它应该返回 $0$ ，否则返回 $1$ 。\n* `allValues(N, W, P)` --- 这个函数需要确定整个排列，并将其存放在给定的数组 $P$ 中：具体来说，$P[i]$ 应该保存物品 $i$ 的权值 $P_i (0 \\leq i \\leq N-1)$。\n在每个测试点中，交互库会一次或多次调用这些函数中的一个。每次函数调用代表不同的任务，哪个函数会被调用、以及最多被调用多少次取决于子任务（见下文）。你可以认为 Koala 在每次函数调用前确定了她的序列 $P$，并且序列不会在一次函数的调用过程中改变。一次调用结束后，她可以在下次函数调用之前改变她的序列。\n你实现的四个函数可以通过调用函数 `playRound` 来获取 Koala 的序列的相关信息。\n* `playRound(B, R)`，请 Koala 和你玩一轮游戏。\n数组 `B` 描述你在每个物品旁边放了多少蓝色石子。具体来说，对任意 $0 \\leq i \\leq N-1$，$B[i]$ 个蓝色石子将会被放在物品 $i$ 旁边。每个 $B[i]$ 必须是一个非负整数，且 $B[0]+B[1]+\\cdots +B[N-1]$ 不能超过 $W$ 。\n交互库会把 Koala 的回应存放在你提供的数组 `R` 中。具体来说，对任意 $0 \\leq i \\leq N-1$，Koala 会在物品 $i$ 旁边放 $R[i]$ 个红色石子。\n每个子任务对你在每次游戏中调用 `playRound` 的次数有所限制。注意，调用次数越少你的得分可能会越高。（具体限制和评分方式参见下文）\n\n## 输入格式\n\n*无*\n\n## 输出格式\n\n*无*\n\n## 说明/提示\n\n\n### 子任务\n\n\n#### 样例数据：$0$ 分\n\n**因为特殊原因（不支持设置 $0$ 分测试点），评测时将不测样例**。\n* 有 $5$ 个「样例数据」测试点，每个测试点恰好调用一次 $4$ 个函数中的某一个。请看下文的「样例」获取各测试点的详细信息。\n* $N=6$\n* $P=5,3,2,1,6,4$\n每次游戏中，你可以调用 `playRound `至多 $3200$ 次。\n\n#### 子任务 1：$4$ 分\n\n* 在这个子任务中，交互库只会调用函数 `minValue`，每个测试点中，这个函数最多会被调用 $100$ 次。\n* $N=100$\n* $W=100$\n* 每一次游戏中，你可以调用 `playRound` 至多 $2$ 次。\n\n#### 子任务 2：$15$ 分\n\n* 在这个子任务中，交互库只会调用函数 `maxValue`。每个测试点中，这个函数最多会被调用 $100$ 次。\n* $N=100$\n* $W=100$\n* 每一次游戏中，你可以调用 `playRound` 至多 $13$ 次。\n* 这个子任务中，一个测试点的分数取决于每一轮游戏中 `playRound` 被调用次数的最大值 $C_{max}$，具体来说，你的得分为：\n- 若 $C_{max}\\leq 4$，获得 $15$ 分。\n- 若 $5 \\leq C_{max} \\leq 13$，获得 $7$ 分。\n\n#### 子任务 3：$18$ 分\n\n* 在这个子任务中，交互库只会调用函数 `greaterValue`。每个测试点中，这个函数最多会被调用 $1100$ 次。\n* $N=100$\n* $W=100$\n* 每一次游戏中，你可以调用 `playRound` 至多 $14$ 次。\n* 这个子任务中，一个测试点的分数取决于每一轮游戏中 `playRound` 被调用次数的最大值 $C_{max}$，具体来说，你的得分为：\n- 若 $C_{max}\\leq 3$，获得 $18$ 分。\n- 若 $C_{max}=4$，获得 $14$ 分。\n- 若 $C_{max}=5$，获得 $11$ 分。\n- 若 $6 \\leq C_{max}\\leq 14$，获得 $5$ 分。\n\n#### 子任务 4：$10$ 分\n\n* 在这个子任务中，交互库只会调用函数 `allValues`，每个测试点中，这个函数会被调用恰好一次。\n* $N=100$\n* $W=200$\n* 你可以调用 `playRound` 至多 $700$ 次。\n\n#### 子任务 5：$53$ 分\n\n* 在这个子任务中，交互库只会调用函数 `allValues`，每个测试点中，这个函数会被调用恰好一次。\n* $N=100$\n* $W=100$\n* 你可以调用 `playRound` 至多 $3200$ 次。\n* 这个子任务中，一个测试点的分数取决于 `playRound` 被调用的次数 $C$ ，具体来说，你的得分为：\n- 若 $C \\leq 100$，获得 $53$ 分。\n- 若 $101 \\leq C \\leq 3200$，获得 $\\lfloor 53-8 \\log_2 (c/100) \\rfloor$ 分。其中，$\\lfloor x \\rfloor$ 为不大于 $x$ 的最大整数。举例来说，若 $C=3200$，那么你的解答将获得 $13$ 分。\n\n### 评分方式\n\n- 和传统题一样，你的程序的运行时间和空间不能超过时间和空间限制。**交互库运行的时间和空间也会算入你的程序的总时间和空间当中**。当你估算这一部分的时空消耗时，你可以认为，在评测时使用的交互库与我们提供的样例交互库有**相同的函数**和**相似的实现**。\n- 在一个测试点中，若你在调用 `playRound` 时传入了非法的数组 B，或调用 `playRound` 的总次数超过了上限，那么该测试点记 $0$ 分。\n- 在一个测试点的任意一次游戏中，若一个函数没有正确地回答所要求的 Koala 的序列的特征，那么该测试点记 $0$ 分。\n- 子任务 4 和子任务 5 均要求你实现函数 `allValues`，但在调用时传入了不同的 $W$。你可以利用两个子任务在这个参数上的不同，从而在你的实现中区分两个子任务。你可以参考你的语言的模板实现获取更详细的信息。\n- 比赛时，你可以提交本题目最多 60 次，连续两次的提交至少间隔 2 分钟。\n- **你在一个子任务上的得分，等于你在该子任务所有测试点中的最低得分**。\n\n### 如何测试你的程序\n\n在终端下输入如下命令进行编译：\n```bash\ng++ grader.cpp koala.cpp -o grader -g -Wall --std=c++11\n```\n\n样例交互库将按如下格式从标准输入读入数据：\n第一行两个整数 $F,G$，其中 $F$ 代表交互库调用的函数类型，$G$ 代表调用函数的次数；\n接下来 $G$ 行，每行开头两个整数 $N,W$，后跟 $N$ 个整数 $P_0,P_1,\\ldots,P_{N-1}$。\n$F$ 对应的样例交互库调用的函数类型如下表所示：\n| $F$ | 调用的函数类型 |\n| ----------- | ----------- |\n| $1$ | `minValue` |\n| $2$ | `maxValue` |\n| $3$ | `greaterValue` |\n| $4$ | `allValues` |\n对于每次函数调用，样例交互库将向标准输出输出两行。第一行代表你调用 `playRound` 的次数，第二行代表函数调用后返回的结构（对于 $F=4$ 的情况，将输出调用 `allValues` 时返回的数组，对于其他情况，将输出函数的返回值）。\n\n### 样例\n\n考虑如下的排列：\n| $i$ | 0 | 1 | 2 | 3 | 4 | 5 |\n| ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- |\n| $P_i$ | 5 | 3 | 2 | 1 | 6 | 4 |\n下表展示了几次调用函数 `playRound` 的例子，以及交互库对每个调用的有效反馈（注意，一次 `playRound` 的调用，可能会有多种可能的有效反馈） 。\n| $W$ | 调用 | 可能的交互库反馈 | 解释 |\n| ----------- | ----------- | ----------- | ----------- |\n| 6 | `playRound([0,3,0,2,1,0],R)` | `R=[1,1,1,0,2,1]` | Koala 获得了物品 $0,2,4,5$，总权值为 $17$，这是一种可能的权值最大的方案。 |\n| 6 | `playRound([1,2,3,1,2,0],R)` | 非法调用 | 你总共放了 $9$ 个石子，超过了 $W$ 的限制。 |\n| 12 | `playRound([0,3,0,2,1,0],R)` | `R=[2,3,0,2,3,1]` | 你不用放完 $W$ 个石子，Koala 也不用放完 $W$ 个石子。 |\n| 6 | `playRound([0,1,0,0,1,0],R)` | `R=[1,0,1,1,2,1]` | 若 Koala 有多种方案最大化获得物品的权值，她会选择使自己获得物品最多的方案。因此 `R=[1,2,0,0,2,1]` 不是一个合法的返回值。 |\n下面是样例数据的返回值，请注意在样例数据中，你可以调用 `playRound` 至多 $3200$ 次。\n| # | 交互库调用 | 期望返回值 | 解释 |\n| ----------- | ----------- | ----------- | ----------- |\n| 1 | `minValue(6,6)` | 3 | $P_3=1$ |\n| 2 | `maxValue(6,6)` | 4 | $P_4=6$ |\n| 3 | `greaterValue(6,6)` | 0 | $P_0=5,P_1=3$ |\n| 4 | `allValues(6,12,P)` | `P=[5,3,2,1,6,4]` | 注意 `allValues` 无返回值，而是将正确结果放入 P 中。 |\n| 5 | `allValues(6,12,P)` | `P=[5,3,2,1,6,4]` | 同上。 |\n\n### 附加文件\n\n附加文件包含样例输入输出，C++ 样例交互库和程序模板，我们推荐您在模板的基础上实现您的程序。", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P3777 [APIO2017] 考拉的游戏\n\n\n## 题目背景\n\n\n### 特别提示\n\n**在洛谷提交本题时的一些注意事项（与原题面不同之处请以此处为准）：**\n1. 提交时请在程序里加入以下函数声明语句：\n```cpp\nvoid playRound(int*,int*);\n```\n\n2. 程序开头不用，也不应该包含 `koala.h` 头文件。\n3. 仅支持 `C++`（含 `C++`，`C++11`，`C++14`，`C++17`）提交。\n\n## 题目描述\n\nKoala 发明了一个新游戏，来邀请你一起玩！游戏的开始，她会在桌上放 $N$ 个物品，物品从 $0$ 到 $N - 1$ 标号。接着，她会秘密地给每个物品分配一个 $1$ 到 $N$ 之间的整数权值，且任意两个物品不会被分配到相同的权值。其中，第 $i$ 个物品的权值为 $P_i$。她请你来确定由这些权值构成的序列 $P=P_0,P_1,\\dots ,P_{N-1}$ 的一些特征。\n为了回答她的问题，你可以请 Koala 玩若干轮游戏。每一轮中，你会得到 $W$ 个蓝色石子，Koala 会得到 $W$ 个红色石子。首先，你可以选择若干个物品，再把你的一些（或全部）石子放在这些物品的旁边。Koala 会观察你的石子分配，然后类似地把她的一些（或全部）石子放在若干个物品旁边。如果一个物品旁边的红色石子数严格大于蓝色石子数，那么，Koala可以获得这个物品。Koala 分配她的石子时，总会选择使她获得的物品的权值和最大的方案，如果有多种方案可以做到这一点，她会选择一种获得的物品数最多的方案，如果仍然有多种方案，她会选择其中任意一种。\nKoala 非常懒，如果你和她玩太多轮游戏，她就会睡着。你的任务是通过尽可能少轮数的游戏，确定 Koala 的序列 $P$ 的相关特征。\n\n### 任务\n\n在这个任务中，你需要实现 $4$ 个函数：`minValue`, `maxValue`, `greaterValue` 和 `allValues`。\n每个函数需要你确定序列 $P$ 的不同特征。我们强烈推荐在我们提供的模版的基础上进行作答。注意，即使你只想获得部分子任务的分数，你也必须为四个函数都提供一个实现（尽管一些函数的内部可能为空）。你的程序禁止从标准输入读数据、向标准输出写数据或与任何文件交互。\n在每个函数中，参数 `N` 表示游戏中物品的个数，参数 `W` 表示你和 Koala 在每一轮游戏中拥有的石子数。\n* `minValue(N, W)` --- 这个函数需要返回权值最小的物品的标号 $i$，即 $P_i=1$\n* `maxValue(N, W)` --- 这个函数需要返回权值最大的物品的标号 $i$，即 $P_i=N$\n* `greaterValue(N, W)` --- 这个函数需要比较物品 $0$ 和物品 $1$ 的权值，返回权值较大的物品的标号。具体来说，若 $P_0>P_1$​，它应该返回 $0$ ，否则返回 $1$ 。\n* `allValues(N, W, P)` --- 这个函数需要确定整个排列，并将其存放在给定的数组 $P$ 中：具体来说，$P[i]$ 应该保存物品 $i$ 的权值 $P_i (0 \\leq i \\leq N-1)$。\n在每个测试点中，交互库会一次或多次调用这些函数中的一个。每次函数调用代表不同的任务，哪个函数会被调用、以及最多被调用多少次取决于子任务（见下文）。你可以认为 Koala 在每次函数调用前确定了她的序列 $P$，并且序列不会在一次函数的调用过程中改变。一次调用结束后，她可以在下次函数调用之前改变她的序列。\n你实现的四个函数可以通过调用函数 `playRound` 来获取 Koala 的序列的相关信息。\n* `playRound(B, R)`，请 Koala 和你玩一轮游戏。\n数组 `B` 描述你在每个物品旁边放了多少蓝色石子。具体来说，对任意 $0 \\leq i \\leq N-1$，$B[i]$ 个蓝色石子将会被放在物品 $i$ 旁边。每个 $B[i]$ 必须是一个非负整数，且 $B[0]+B[1]+\\cdots +B[N-1]$ 不能超过 $W$ 。\n交互库会把 Koala 的回应存放在你提供的数组 `R` 中。具体来说，对任意 $0 \\leq i \\leq N-1$，Koala 会在物品 $i$ 旁边放 $R[i]$ 个红色石子。\n每个子任务对你在每次游戏中调用 `playRound` 的次数有所限制。注意，调用次数越少你的得分可能会越高。（具体限制和评分方式参见下文）\n\n## 输入格式\n\n*无*\n\n## 输出格式\n\n*无*\n\n## 说明/提示\n\n\n### 子任务\n\n\n#### 样例数据：$0$ 分\n\n**因为特殊原因（不支持设置 $0$ 分测试点），评测时将不测样例**。\n* 有 $5$ 个「样例数据」测试点，每个测试点恰好调用一次 $4$ 个函数中的某一个。请看下文的「样例」获取各测试点的详细信息。\n* $N=6$\n* $P=5,3,2,1,6,4$\n每次游戏中，你可以调用 `playRound `至多 $3200$ 次。\n\n#### 子任务 1：$4$ 分\n\n* 在这个子任务中，交互库只会调用函数 `minValue`，每个测试点中，这个函数最多会被调用 $100$ 次。\n* $N=100$\n* $W=100$\n* 每一次游戏中，你可以调用 `playRound` 至多 $2$ 次。\n\n#### 子任务 2：$15$ 分\n\n* 在这个子任务中，交互库只会调用函数 `maxValue`。每个测试点中，这个函数最多会被调用 $100$ 次。\n* $N=100$\n* $W=100$\n* 每一次游戏中，你可以调用 `playRound` 至多 $13$ 次。\n* 这个子任务中，一个测试点的分数取决于每一轮游戏中 `playRound` 被调用次数的最大值 $C_{max}$，具体来说，你的得分为：\n- 若 $C_{max}\\leq 4$，获得 $15$ 分。\n- 若 $5 \\leq C_{max} \\leq 13$，获得 $7$ 分。\n\n#### 子任务 3：$18$ 分\n\n* 在这个子任务中，交互库只会调用函数 `greaterValue`。每个测试点中，这个函数最多会被调用 $1100$ 次。\n* $N=100$\n* $W=100$\n* 每一次游戏中，你可以调用 `playRound` 至多 $14$ 次。\n* 这个子任务中，一个测试点的分数取决于每一轮游戏中 `playRound` 被调用次数的最大值 $C_{max}$，具体来说，你的得分为：\n- 若 $C_{max}\\leq 3$，获得 $18$ 分。\n- 若 $C_{max}=4$，获得 $14$ 分。\n- 若 $C_{max}=5$，获得 $11$ 分。\n- 若 $6 \\leq C_{max}\\leq 14$，获得 $5$ 分。\n\n#### 子任务 4：$10$ 分\n\n* 在这个子任务中，交互库只会调用函数 `allValues`，每个测试点中，这个函数会被调用恰好一次。\n* $N=100$\n* $W=200$\n* 你可以调用 `playRound` 至多 $700$ 次。\n\n#### 子任务 5：$53$ 分\n\n* 在这个子任务中，交互库只会调用函数 `allValues`，每个测试点中，这个函数会被调用恰好一次。\n* $N=100$\n* $W=100$\n* 你可以调用 `playRound` 至多 $3200$ 次。\n* 这个子任务中，一个测试点的分数取决于 `playRound` 被调用的次数 $C$ ，具体来说，你的得分为：\n- 若 $C \\leq 100$，获得 $53$ 分。\n- 若 $101 \\leq C \\leq 3200$，获得 $\\lfloor 53-8 \\log_2 (c/100) \\rfloor$ 分。其中，$\\lfloor x \\rfloor$ 为不大于 $x$ 的最大整数。举例来说，若 $C=3200$，那么你的解答将获得 $13$ 分。\n\n### 评分方式\n\n- 和传统题一样，你的程序的运行时间和空间不能超过时间和空间限制。**交互库运行的时间和空间也会算入你的程序的总时间和空间当中**。当你估算这一部分的时空消耗时，你可以认为，在评测时使用的交互库与我们提供的样例交互库有**相同的函数**和**相似的实现**。\n- 在一个测试点中，若你在调用 `playRound` 时传入了非法的数组 B，或调用 `playRound` 的总次数超过了上限，那么该测试点记 $0$ 分。\n- 在一个测试点的任意一次游戏中，若一个函数没有正确地回答所要求的 Koala 的序列的特征，那么该测试点记 $0$ 分。\n- 子任务 4 和子任务 5 均要求你实现函数 `allValues`，但在调用时传入了不同的 $W$。你可以利用两个子任务在这个参数上的不同，从而在你的实现中区分两个子任务。你可以参考你的语言的模板实现获取更详细的信息。\n- 比赛时，你可以提交本题目最多 60 次，连续两次的提交至少间隔 2 分钟。\n- **你在一个子任务上的得分，等于你在该子任务所有测试点中的最低得分**。\n\n### 如何测试你的程序\n\n在终端下输入如下命令进行编译：\n```bash\ng++ grader.cpp koala.cpp -o grader -g -Wall --std=c++11\n```\n\n样例交互库将按如下格式从标准输入读入数据：\n第一行两个整数 $F,G$，其中 $F$ 代表交互库调用的函数类型，$G$ 代表调用函数的次数；\n接下来 $G$ 行，每行开头两个整数 $N,W$，后跟 $N$ 个整数 $P_0,P_1,\\ldots,P_{N-1}$。\n$F$ 对应的样例交互库调用的函数类型如下表所示：\n| $F$ | 调用的函数类型 |\n| ----------- | ----------- |\n| $1$ | `minValue` |\n| $2$ | `maxValue` |\n| $3$ | `greaterValue` |\n| $4$ | `allValues` |\n对于每次函数调用，样例交互库将向标准输出输出两行。第一行代表你调用 `playRound` 的次数，第二行代表函数调用后返回的结构（对于 $F=4$ 的情况，将输出调用 `allValues` 时返回的数组，对于其他情况，将输出函数的返回值）。\n\n### 样例\n\n考虑如下的排列：\n| $i$ | 0 | 1 | 2 | 3 | 4 | 5 |\n| ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- |\n| $P_i$ | 5 | 3 | 2 | 1 | 6 | 4 |\n下表展示了几次调用函数 `playRound` 的例子，以及交互库对每个调用的有效反馈（注意，一次 `playRound` 的调用，可能会有多种可能的有效反馈） 。\n| $W$ | 调用 | 可能的交互库反馈 | 解释 |\n| ----------- | ----------- | ----------- | ----------- |\n| 6 | `playRound([0,3,0,2,1,0],R)` | `R=[1,1,1,0,2,1]` | Koala 获得了物品 $0,2,4,5$，总权值为 $17$，这是一种可能的权值最大的方案。 |\n| 6 | `playRound([1,2,3,1,2,0],R)` | 非法调用 | 你总共放了 $9$ 个石子，超过了 $W$ 的限制。 |\n| 12 | `playRound([0,3,0,2,1,0],R)` | `R=[2,3,0,2,3,1]` | 你不用放完 $W$ 个石子，Koala 也不用放完 $W$ 个石子。 |\n| 6 | `playRound([0,1,0,0,1,0],R)` | `R=[1,0,1,1,2,1]` | 若 Koala 有多种方案最大化获得物品的权值，她会选择使自己获得物品最多的方案。因此 `R=[1,2,0,0,2,1]` 不是一个合法的返回值。 |\n下面是样例数据的返回值，请注意在样例数据中，你可以调用 `playRound` 至多 $3200$ 次。\n| # | 交互库调用 | 期望返回值 | 解释 |\n| ----------- | ----------- | ----------- | ----------- |\n| 1 | `minValue(6,6)` | 3 | $P_3=1$ |\n| 2 | `maxValue(6,6)` | 4 | $P_4=6$ |\n| 3 | `greaterValue(6,6)` | 0 | $P_0=5,P_1=3$ |\n| 4 | `allValues(6,12,P)` | `P=[5,3,2,1,6,4]` | 注意 `allValues` 无返回值，而是将正确结果放入 P 中。 |\n| 5 | `allValues(6,12,P)` | `P=[5,3,2,1,6,4]` | 同上。 |\n\n### 附加文件\n\n附加文件包含样例输入输出，C++ 样例交互库和程序模板，我们推荐您在模板的基础上实现您的程序。", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P3798 辉夜姬的十道难题\n\n\n## 题目背景\n\n妹红最近玩了一款叫 $2048$ 的小游戏。\n\n(图为个人无撤销最高纪录~ 纯手玩)。\n\n## 题目描述\n\n$2048$ 是一个非常简单的数字游戏，它在 $4\\times 4$ 的棋盘上进行，通过移动来合并数字，达到 $2048$ 即算胜利。妹红最近沉迷上了这个游戏，事情传到辉夜那里后，辉夜决定用曾经无人破解的十道难题来考考妹红。\n游戏规则：\n1. 游戏在 $n\\times m$ 的方格棋盘上进行。\n2. 两个玩家，其中一个可以移动棋盘上的数字，记做 M，另外一个可以向棋盘上放数字，记做 C。\n3. 移动数字的规则如下：可以向上/下/左/右四个方向的其中之一移动。选定好方向后，所有数字都会向该方向靠拢，相同的两个数字相撞时会合并成一个新数字，这个数字是它们的和。在一次移动中，每个数字最多只能合并一次，优先合并靠近移动方向棋盘边缘的数字。\n以 $n=2,m=4$ 的情况举例如下（$0$ 表示该位置为空）：\n```\n2 2 2 2\n2 2 0 2\n```\n\n向左移动后变为：\n```\n4 4 0 0\n4 2 0 0\n```\n\n每次合并后，将会获得一定的分数，获得的分数等于所有合并后数字相加之和。若无任何合并发生，则不得分。在上例中，得分为 $12$。\n移动前后，若棋盘上的所有数字大小和位置均没有变化，则不算做有效移动，否则即是有效移动。\n4. 向棋盘放置数字的规则如下：只能选择棋盘上没有数字的位置放置一个数字，可以放置的数字和放置方法在每个子任务中会具体描述。\n5. 游戏开始时棋盘为空，分数为 $0$。先由玩家 C 行动两步，接着玩家 M 和 C 轮流行动，中间的每一步都必须是有效的。当轮到玩家 M 时，若不能够进行有效移动，则游戏结束，此时的得分为最终得分。\n本题目为提交答案题，共有 $10$ 个子任务需要你来完成。将你的答案写到 $10$ 个文件中，分别命名为 ```gamex.out```，$x$ 表示子任务的编号（$0\\ldots 9$）。\n子任务内无部分分，你可以得到该任务的分数当且仅当你的输出和标准答案完全相同。\n十道难题如下:\n0. $n=1,m=2$。玩家 C 行动时可以放置 $2$ 或 $4$。若用 $x$ 表示在一局游戏中玩家 M 最多可以行动 $x$ 次，那么这个 $x$ 的最值是多少？输出两行，第一行一个整数表示 $x$ 的最小值，第二行一个整数表示 $x$ 的最大值。\n1. $n=10738029,m=921023$。玩家 C 行动时可以放置 $2$ 或 $4$。若用 $x$ 表示棋盘上所有数字之和，请问 $x$ 的最大值是多少。因为这个值可能过大，只需要输出它除以 $10^9+7$ 的余数即可。\n2. $n=2,m=2$。玩家 C 行动时可以放置 $2,4$。用 $x$ 表示目标数字， $x$ 一定为 $2$ 的正整数幂。玩家 M 的目标是使盘面上出现大于等于数字 $x$ 的数，玩家 C 的目标是在盘面上出现数字 $x$ 之前使游戏结束。在两方均最优决策的情况下，求一个最大的 $x$，使得玩家 M 能达到自己的目标。\n3. $n=4,m=4$。玩家 C 行动时可以放置 $2,4$。输出两行，每行一个数字。第一行的数字表示能达到的最大分数。第二行的数字表示当数字总和达到最大时，分数的最小值。\n4. $n=7393,m=9133$。玩家 C 可以放置数字 $2$ 共 $6144$ 次。棋盘初始为空，初始分数为 $0$。首先由玩家 C 连续行动，直到用完所有放置机会或中途主动放弃。然后连续向上移动直到向上方向不能构成有效移动。输出一行一个整数，表示最大得分。\n5. $n=7,m=233$。初始分数为 $0$,玩家 C 可以放置数字 $2$ 共 $233$ 次，数字 $4$ 共 $66$ 次。棋盘第一行一开始有若干数字，第 $i$ 列的数字为 $\\text{lowbit}(i)\\times 2$，$\\text{lowbit}(i)$ 表示数字 $i$ 的二进制形式只取最后一个 $1$ 构成的数字。如 $\\text{lowbit}(1\\ldots 8)$ 为 $1,2,1,4,1,2,1,8$。棋盘的其他位置均为空。首先由玩家 C 连续行动，直到用完所有放置机会或中途主动放弃。然后连续向上移动直到向上方向不能构成有效移动。输出一行一个整数，表示最大得分。\n6. $n=3,m=3$。玩家 C 行动时可以放置 $2,4$。用 $x$ 表示目标数字，$x$ 一定为 $2$ 的正整数幂。玩家 M 的目标是使盘面上出现数字 $x$，玩家 C 的目标是在盘面上出现数字 $x$ 之前使游戏结束。在两方均最优决策的情况下，输出一个最大的 $x$，使得玩家 M 能达到自己的目标。\n7. $n=3,m=3$。玩家 C 行动时可以放置 $2,4$。玩家 M 的目标是让得分最大化，玩家 C 的目标是让得分最小化，在两方均最优决策的情况下，输出一个整数，表示最终的分数。\n8. $n=3,m=3$。玩家 C 行动时，有 $90\\%$ 的几率放置一个 $2$，$10\\%$ 的几率放置一个 $4$，放置在各个空位的几率均等。用 $x$ 表示目标数字，玩家 M 的目标是使盘面上出现大于等于数字 $x$ 的数。在玩家 M 最优决策的情况下，输出一行，$9$ 个实数，四舍五入到小数点后 $2$ 位，用空格隔开，分别表示 $x=2,4,8,16,32,64,128,256,512$ 时，达成目标数字的概率。\n9. $n=3,m=3$。玩家 C 行动时，有 $90\\%$ 的几率放置一个 $2$，$10\\%$ 的几率放置一个 $4$，放置在各个空位的几率均等。玩家 M 的目标是让分数最大化。在玩家 M 最优决策的情况下，输出一个实数，四舍五入保留整数，表示分数的期望值。\n妹红虽然对 $2048$ 有一定了解，但她并不能解决全部的问题，于是就交给了学 OI 的你。\n\n## 输入格式\n\n见题目描述\n\n## 输出格式\n\n见题目描述\n\n## 说明/提示\n\n如果对移动规则有疑惑，可以到 $2048$ 网站进行尝试:\nhttp://gabrielecirulli.github.io/2048/\nby-orangebird\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n样例任务（无需提交）:\n n=2,m=2。 玩家C行动时只可以放置2。请输出一个整数，表示棋盘上可能出现的最大数字。\n```\n\n**输出：**\n```\n16\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P3798 辉夜姬的十道难题\n\n\n## 题目背景\n\n妹红最近玩了一款叫 $2048$ 的小游戏。\n\n(图为个人无撤销最高纪录~ 纯手玩)。\n\n## 题目描述\n\n$2048$ 是一个非常简单的数字游戏，它在 $4\\times 4$ 的棋盘上进行，通过移动来合并数字，达到 $2048$ 即算胜利。妹红最近沉迷上了这个游戏，事情传到辉夜那里后，辉夜决定用曾经无人破解的十道难题来考考妹红。\n游戏规则：\n1. 游戏在 $n\\times m$ 的方格棋盘上进行。\n2. 两个玩家，其中一个可以移动棋盘上的数字，记做 M，另外一个可以向棋盘上放数字，记做 C。\n3. 移动数字的规则如下：可以向上/下/左/右四个方向的其中之一移动。选定好方向后，所有数字都会向该方向靠拢，相同的两个数字相撞时会合并成一个新数字，这个数字是它们的和。在一次移动中，每个数字最多只能合并一次，优先合并靠近移动方向棋盘边缘的数字。\n以 $n=2,m=4$ 的情况举例如下（$0$ 表示该位置为空）：\n```\n2 2 2 2\n2 2 0 2\n```\n\n向左移动后变为：\n```\n4 4 0 0\n4 2 0 0\n```\n\n每次合并后，将会获得一定的分数，获得的分数等于所有合并后数字相加之和。若无任何合并发生，则不得分。在上例中，得分为 $12$。\n移动前后，若棋盘上的所有数字大小和位置均没有变化，则不算做有效移动，否则即是有效移动。\n4. 向棋盘放置数字的规则如下：只能选择棋盘上没有数字的位置放置一个数字，可以放置的数字和放置方法在每个子任务中会具体描述。\n5. 游戏开始时棋盘为空，分数为 $0$。先由玩家 C 行动两步，接着玩家 M 和 C 轮流行动，中间的每一步都必须是有效的。当轮到玩家 M 时，若不能够进行有效移动，则游戏结束，此时的得分为最终得分。\n本题目为提交答案题，共有 $10$ 个子任务需要你来完成。将你的答案写到 $10$ 个文件中，分别命名为 ```gamex.out```，$x$ 表示子任务的编号（$0\\ldots 9$）。\n子任务内无部分分，你可以得到该任务的分数当且仅当你的输出和标准答案完全相同。\n十道难题如下:\n0. $n=1,m=2$。玩家 C 行动时可以放置 $2$ 或 $4$。若用 $x$ 表示在一局游戏中玩家 M 最多可以行动 $x$ 次，那么这个 $x$ 的最值是多少？输出两行，第一行一个整数表示 $x$ 的最小值，第二行一个整数表示 $x$ 的最大值。\n1. $n=10738029,m=921023$。玩家 C 行动时可以放置 $2$ 或 $4$。若用 $x$ 表示棋盘上所有数字之和，请问 $x$ 的最大值是多少。因为这个值可能过大，只需要输出它除以 $10^9+7$ 的余数即可。\n2. $n=2,m=2$。玩家 C 行动时可以放置 $2,4$。用 $x$ 表示目标数字， $x$ 一定为 $2$ 的正整数幂。玩家 M 的目标是使盘面上出现大于等于数字 $x$ 的数，玩家 C 的目标是在盘面上出现数字 $x$ 之前使游戏结束。在两方均最优决策的情况下，求一个最大的 $x$，使得玩家 M 能达到自己的目标。\n3. $n=4,m=4$。玩家 C 行动时可以放置 $2,4$。输出两行，每行一个数字。第一行的数字表示能达到的最大分数。第二行的数字表示当数字总和达到最大时，分数的最小值。\n4. $n=7393,m=9133$。玩家 C 可以放置数字 $2$ 共 $6144$ 次。棋盘初始为空，初始分数为 $0$。首先由玩家 C 连续行动，直到用完所有放置机会或中途主动放弃。然后连续向上移动直到向上方向不能构成有效移动。输出一行一个整数，表示最大得分。\n5. $n=7,m=233$。初始分数为 $0$,玩家 C 可以放置数字 $2$ 共 $233$ 次，数字 $4$ 共 $66$ 次。棋盘第一行一开始有若干数字，第 $i$ 列的数字为 $\\text{lowbit}(i)\\times 2$，$\\text{lowbit}(i)$ 表示数字 $i$ 的二进制形式只取最后一个 $1$ 构成的数字。如 $\\text{lowbit}(1\\ldots 8)$ 为 $1,2,1,4,1,2,1,8$。棋盘的其他位置均为空。首先由玩家 C 连续行动，直到用完所有放置机会或中途主动放弃。然后连续向上移动直到向上方向不能构成有效移动。输出一行一个整数，表示最大得分。\n6. $n=3,m=3$。玩家 C 行动时可以放置 $2,4$。用 $x$ 表示目标数字，$x$ 一定为 $2$ 的正整数幂。玩家 M 的目标是使盘面上出现数字 $x$，玩家 C 的目标是在盘面上出现数字 $x$ 之前使游戏结束。在两方均最优决策的情况下，输出一个最大的 $x$，使得玩家 M 能达到自己的目标。\n7. $n=3,m=3$。玩家 C 行动时可以放置 $2,4$。玩家 M 的目标是让得分最大化，玩家 C 的目标是让得分最小化，在两方均最优决策的情况下，输出一个整数，表示最终的分数。\n8. $n=3,m=3$。玩家 C 行动时，有 $90\\%$ 的几率放置一个 $2$，$10\\%$ 的几率放置一个 $4$，放置在各个空位的几率均等。用 $x$ 表示目标数字，玩家 M 的目标是使盘面上出现大于等于数字 $x$ 的数。在玩家 M 最优决策的情况下，输出一行，$9$ 个实数，四舍五入到小数点后 $2$ 位，用空格隔开，分别表示 $x=2,4,8,16,32,64,128,256,512$ 时，达成目标数字的概率。\n9. $n=3,m=3$。玩家 C 行动时，有 $90\\%$ 的几率放置一个 $2$，$10\\%$ 的几率放置一个 $4$，放置在各个空位的几率均等。玩家 M 的目标是让分数最大化。在玩家 M 最优决策的情况下，输出一个实数，四舍五入保留整数，表示分数的期望值。\n妹红虽然对 $2048$ 有一定了解，但她并不能解决全部的问题，于是就交给了学 OI 的你。\n\n## 输入格式\n\n见题目描述\n\n## 输出格式\n\n见题目描述\n\n## 说明/提示\n\n如果对移动规则有疑惑，可以到 $2048$ 网站进行尝试:\nhttp://gabrielecirulli.github.io/2048/\nby-orangebird\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n样例任务（无需提交）:\n n=2,m=2。 玩家C行动时只可以放置2。请输出一个整数，表示棋盘上可能出现的最大数字。\n```\n\n**输出：**\n```\n16\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P3840 [IOI 2017] 西默夫\n\n\n## 题目背景\n\n**本题暂不支持提交。**\n时间限制：3s，内存限制：1024MB。\n\n## 题目描述\n\n根据沙纳玛（Shahnameh）中的古代波斯传说，Zal，传奇的波斯英雄，疯狂地爱上了 Kabul 王国的公主 Rudaba。在 Zal 向 Rudaba 求婚时，Rudaba 的父亲给他了一个挑战。\n在波斯有 $n$ 个城市，标记为从 $0$ 到 $n - 1$，以及 $m$ 条双向道路，标记为从 $0$ 到 $m - 1$。每条道路连接两个不同的城市。每一对城市至多会被一条道路连接。有些道路是御道（royal roads），专用于皇室行驶，但这是保密的。Zal 的任务是找出哪些道路是御道。\nZal 有一张包括所有城市和所有道路的波斯地图。他不知道哪些道路是御道，但是他可以求救于 Simurgh——好心的神鸟、Zal 的保护者。然而，Simurgh 并不想直接告诉他哪些道路是御道。作为替代，Simurgh 告诉 Zal，所有御道的集合是一个黄金集合（golden set）。一个道路的集合是黄金集合，当且仅当：\n- 它恰好包含 $n - 1$ 条道路，而且\n- 对于每一对城市，仅沿着这个集合中的道路即可从其中一个城市抵达另外一个城市。\n此外，Zal 可以问 Simurgh 一些问题。对于每个问题：\n1. Zal 选出道路的一个黄金集合，然后\n2. Simurgh 会告诉 Zal，在所选择的黄金集合中有多少条道路是御道。\n你的程序可以问 Simurgh 最多 $q$ 个问题，以此帮助 Zal 找出御道的集合。评测工具将扮演 Simurgh 的角色。\n\n### 实现细节\n\n你需要实现下面的函数：\n```cpp\nint[] find_roads(int n, int[] u, int[] v)\n```\n\n- $n$：城市的数量，\n- $u$ 和 $v$：均为长度为 $m$ 的数组。对于所有 $0 \\le i \\le m - 1$，$u[i]$ 和 $v[i]$ 是被道路 $i$ 所连接的城市。\n- 该函数需要返回一个长度为 $n - 1$ 的数组，其中包括了所有御道的标号（可以以任意的顺序给出）。\n你的程序至多只能调用评测工具中的如下函数 $q$ 次：\n```cpp\nint count_common_roads(int[] r)\n```\n\n- $r$：长度为 $n - 1$ 的数组，其中包括了一个黄金集合中的道路标号（可以以任意的顺序给出）。\n- 该函数将返回 $r$ 中的御道数量。\n\n## 输入格式\n\n无\n\n## 输出格式\n\n无\n\n## 说明/提示\n\n\n### 例子\n\n```\nfind_roads(4, [0, 0, 0, 1, 1, 2], [1, 2, 3, 2, 3, 3])\n```\n\n\n这个例子中有 $4$ 个城市和 $6$ 条道路。我们将连接城市 $a$ 和 $b$ 的道路表示为 $(a, b)$。这些道路按照下面的顺序被标为从 $0$ 到 $5$：$(0, 1)$，$(0, 2)$，$(0, 3)$，$(1, 2)$，$(1, 3)$ 和 $(2, 3)$。每个黄金集合包含 $n - 1 = 3$ 条道路。\n假设御道是标号为 $0$，$1$ 和 $5$ 的道路，即 $(0, 1)$，$(0, 2)$ 和 $(2,3)$。这样的话：\n- `count_common_roads([0, 1, 2])` 返回 $2$。该询问涉及到标号为 $0, 1$ 和 $2$ 的道路，即 $(0, 1)$，$(0, 2)$ 和 $(0, 3)$。其中有两条道路是御道。\n- `count_common_roads([5, 1, 0])` 返回 $3$。该询问涉及到所有的御道。\n函数 `find_roads` 需要返回 `[5, 1, 0]` 或任意其他包含这三个元素且长度为 $3$ 的数组。\n注意，下面列出的调用是不允许的：\n- `count_common_roads([0, 1])`：这里 $r$ 的长度不是 $3$。\n- `count_common_roads([0, 1, 3])`：这里 $r$ 不是一个黄金集合，因为无法仅沿道路 $(0, 1)$，$(0, 2)$，$(1, 2)$ 就从城市 $0$ 走到城市 $3$。\n\n### 限制条件\n\n- $2 \\le n \\le 500$\n- $n - 1 \\le m \\le n(n - 1) / 2$\n- $0 \\le u[i],v[i] \\le n - 1$（对于所有 $0 \\le i \\le m - 1$）\n- 对于所有 $0 \\le i \\le m - 1$，道路 $i$ 连接两个不同的城市（即 $u[i] \\neq v[i]$）。\n- 每对城市之间至多连有一条道路。\n- 经由这些道路，可以在任意一对城市之间来往。\n- 所有的御道组成一个黄金集合。\n- `find_roads` 可以调用 `count_common_roads` 最多 $q$ 次。在每次调用中，由 $r$ 所给出的道路必须是一个黄金集合。\n\n### 子任务\n\n1. （13 分）$n \\le 7$，$q = 30000$\n2. （17 分）$n \\le 50$，$q = 30000$\n3. （21 分）$n \\le 240$，$q = 30000$\n4. （19 分）$q = 12000$，在任意两个城市之间都连有一条道路\n5. （30 分）$q = 8000$\n\n### 评测工具示例\n\n评测工具示例将读入下述格式的输入数据：\n- 第 $1$ 行：$n\\ m$\n- 第 $2 + i$ 行（对于所有 $0 \\le i \\le m - 1$）：$u[i]\\ v[i]$\n- 第 $2 + m$ 行：$s[0]\\ s[1]\\ \\dots\\ s[n - 2]$\n这里 $s[0], s[1], \\dots, s[n - 2]$ 是所有御道的编号。\n如果 `find_roads` 最多调用 `count_common_roads` 了 $30000$ 次，而且正确地返回了御道的集合，评测工具示例将会输出 `YES`。否则评测工具示例将会输出 `NO`。\n需要明确的是，评测工具示例中的函数 `count_common_roads` 不会检查 $r$ 是否满足一个黄金集合的所有条件。替代性地，它会对数组中的御道 $r$ 进行计数，并且返回。然而，在你提交的程序调用 `count_common_roads` 时，如果传给它的不是对应某个黄金集合的标号集合，评测结果将会是 'Wrong Answer'。\n\n### 技术提示\n\n出于效率方面的考虑，面向 C++ 和 Pascal 的函数 `count_common_roads` 使用了传引用调用（call by\nreference）的方式。你可以与平常一样调用这个函数。评测工具确保不会改变 $r$ 中的值。\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\nn = 4\nu = [0, 0, 0, 1, 1, 2]\nv = [1, 2, 3, 2, 3, 3]\n```\n\n**输出：**\n```\n一个可能的输出：\n[0, 1, 5]\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P3840 [IOI 2017] 西默夫\n\n\n## 题目背景\n\n**本题暂不支持提交。**\n时间限制：3s，内存限制：1024MB。\n\n## 题目描述\n\n根据沙纳玛（Shahnameh）中的古代波斯传说，Zal，传奇的波斯英雄，疯狂地爱上了 Kabul 王国的公主 Rudaba。在 Zal 向 Rudaba 求婚时，Rudaba 的父亲给他了一个挑战。\n在波斯有 $n$ 个城市，标记为从 $0$ 到 $n - 1$，以及 $m$ 条双向道路，标记为从 $0$ 到 $m - 1$。每条道路连接两个不同的城市。每一对城市至多会被一条道路连接。有些道路是御道（royal roads），专用于皇室行驶，但这是保密的。Zal 的任务是找出哪些道路是御道。\nZal 有一张包括所有城市和所有道路的波斯地图。他不知道哪些道路是御道，但是他可以求救于 Simurgh——好心的神鸟、Zal 的保护者。然而，Simurgh 并不想直接告诉他哪些道路是御道。作为替代，Simurgh 告诉 Zal，所有御道的集合是一个黄金集合（golden set）。一个道路的集合是黄金集合，当且仅当：\n- 它恰好包含 $n - 1$ 条道路，而且\n- 对于每一对城市，仅沿着这个集合中的道路即可从其中一个城市抵达另外一个城市。\n此外，Zal 可以问 Simurgh 一些问题。对于每个问题：\n1. Zal 选出道路的一个黄金集合，然后\n2. Simurgh 会告诉 Zal，在所选择的黄金集合中有多少条道路是御道。\n你的程序可以问 Simurgh 最多 $q$ 个问题，以此帮助 Zal 找出御道的集合。评测工具将扮演 Simurgh 的角色。\n\n### 实现细节\n\n你需要实现下面的函数：\n```cpp\nint[] find_roads(int n, int[] u, int[] v)\n```\n\n- $n$：城市的数量，\n- $u$ 和 $v$：均为长度为 $m$ 的数组。对于所有 $0 \\le i \\le m - 1$，$u[i]$ 和 $v[i]$ 是被道路 $i$ 所连接的城市。\n- 该函数需要返回一个长度为 $n - 1$ 的数组，其中包括了所有御道的标号（可以以任意的顺序给出）。\n你的程序至多只能调用评测工具中的如下函数 $q$ 次：\n```cpp\nint count_common_roads(int[] r)\n```\n\n- $r$：长度为 $n - 1$ 的数组，其中包括了一个黄金集合中的道路标号（可以以任意的顺序给出）。\n- 该函数将返回 $r$ 中的御道数量。\n\n## 输入格式\n\n无\n\n## 输出格式\n\n无\n\n## 说明/提示\n\n\n### 例子\n\n```\nfind_roads(4, [0, 0, 0, 1, 1, 2], [1, 2, 3, 2, 3, 3])\n```\n\n\n这个例子中有 $4$ 个城市和 $6$ 条道路。我们将连接城市 $a$ 和 $b$ 的道路表示为 $(a, b)$。这些道路按照下面的顺序被标为从 $0$ 到 $5$：$(0, 1)$，$(0, 2)$，$(0, 3)$，$(1, 2)$，$(1, 3)$ 和 $(2, 3)$。每个黄金集合包含 $n - 1 = 3$ 条道路。\n假设御道是标号为 $0$，$1$ 和 $5$ 的道路，即 $(0, 1)$，$(0, 2)$ 和 $(2,3)$。这样的话：\n- `count_common_roads([0, 1, 2])` 返回 $2$。该询问涉及到标号为 $0, 1$ 和 $2$ 的道路，即 $(0, 1)$，$(0, 2)$ 和 $(0, 3)$。其中有两条道路是御道。\n- `count_common_roads([5, 1, 0])` 返回 $3$。该询问涉及到所有的御道。\n函数 `find_roads` 需要返回 `[5, 1, 0]` 或任意其他包含这三个元素且长度为 $3$ 的数组。\n注意，下面列出的调用是不允许的：\n- `count_common_roads([0, 1])`：这里 $r$ 的长度不是 $3$。\n- `count_common_roads([0, 1, 3])`：这里 $r$ 不是一个黄金集合，因为无法仅沿道路 $(0, 1)$，$(0, 2)$，$(1, 2)$ 就从城市 $0$ 走到城市 $3$。\n\n### 限制条件\n\n- $2 \\le n \\le 500$\n- $n - 1 \\le m \\le n(n - 1) / 2$\n- $0 \\le u[i],v[i] \\le n - 1$（对于所有 $0 \\le i \\le m - 1$）\n- 对于所有 $0 \\le i \\le m - 1$，道路 $i$ 连接两个不同的城市（即 $u[i] \\neq v[i]$）。\n- 每对城市之间至多连有一条道路。\n- 经由这些道路，可以在任意一对城市之间来往。\n- 所有的御道组成一个黄金集合。\n- `find_roads` 可以调用 `count_common_roads` 最多 $q$ 次。在每次调用中，由 $r$ 所给出的道路必须是一个黄金集合。\n\n### 子任务\n\n1. （13 分）$n \\le 7$，$q = 30000$\n2. （17 分）$n \\le 50$，$q = 30000$\n3. （21 分）$n \\le 240$，$q = 30000$\n4. （19 分）$q = 12000$，在任意两个城市之间都连有一条道路\n5. （30 分）$q = 8000$\n\n### 评测工具示例\n\n评测工具示例将读入下述格式的输入数据：\n- 第 $1$ 行：$n\\ m$\n- 第 $2 + i$ 行（对于所有 $0 \\le i \\le m - 1$）：$u[i]\\ v[i]$\n- 第 $2 + m$ 行：$s[0]\\ s[1]\\ \\dots\\ s[n - 2]$\n这里 $s[0], s[1], \\dots, s[n - 2]$ 是所有御道的编号。\n如果 `find_roads` 最多调用 `count_common_roads` 了 $30000$ 次，而且正确地返回了御道的集合，评测工具示例将会输出 `YES`。否则评测工具示例将会输出 `NO`。\n需要明确的是，评测工具示例中的函数 `count_common_roads` 不会检查 $r$ 是否满足一个黄金集合的所有条件。替代性地，它会对数组中的御道 $r$ 进行计数，并且返回。然而，在你提交的程序调用 `count_common_roads` 时，如果传给它的不是对应某个黄金集合的标号集合，评测结果将会是 'Wrong Answer'。\n\n### 技术提示\n\n出于效率方面的考虑，面向 C++ 和 Pascal 的函数 `count_common_roads` 使用了传引用调用（call by\nreference）的方式。你可以与平常一样调用这个函数。评测工具确保不会改变 $r$ 中的值。\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\nn = 4\nu = [0, 0, 0, 1, 1, 2]\nv = [1, 2, 3, 2, 3, 3]\n```\n\n**输出：**\n```\n一个可能的输出：\n[0, 1, 5]\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P3864 [USACO1.2] 命名那个数字 Name That Number\n\n\n## 题目描述\n\n在威斯康辛州牛守志大农场经营者之中，都习惯于请会计部门用连续数字给母牛打上烙印。但是,母牛本身并没感到这个系统的便利,它们更喜欢用它们喜欢的名字来呼叫它们的同伴，而不是用像这个的语句\"C'mon, #4364, get along.\"。请写一个程序来帮助可怜的牧牛工将一只母牛的烙印编号翻译成一个可能的名字。因为母牛们现在都有手机了，使用标准的按键的排布来把将数目翻译为文字:( 除了 \"Q\" 和 \"Z\")\n```\n2: A,B,C     5: J,K,L    8: T,U,V\n3: D,E,F     6: M,N,O    9: W,X,Y\n4: G,H,I     7: P,R,S\n```\n\n可接受的名字都被放在这样一个叫作\"dict.txt\" 的文件中，它包含一连串的少于 5,000个（准确地说是4617个）可被接受的牛的名字。 (所有的名字都是大写的且已按字典序排列) 请读入母牛的编号并返回那些能从编号翻译出来并且在字典中的名字。举例来说,编号 4734 能产生的下列各项名字: GPDG GPDH GPDI GPEG GPEH GPEI GPFG GPFH GPFI GRDG GRDH GRDI GREG GREH GREI GRFG GRFH GRFI GSDG GSDH GSDI GSEG GSEH GSEI GSFG GSFH GSFI HPDG HPDH HPDI HPEG HPEH HPEI HPFG HPFH HPFI HRDG HRDH HRDI HREG HREH HREI HRFG HRFH HRFI HSDG HSDH HSDI HSEG HSEH HSEI HSFG HSFH HSFI IPDG IPDH IPDI IPEG IPEH IPEI IPFG IPFH IPFI IRDG IRDH IRDI IREG IREH IREI IRFG IRFH IRFI ISDG ISDH ISDI ISEG ISEH ISEI ISFG ISFH ISFI 碰巧，81个中只有一个\"GREG\"是有效的(在字典中)。\n写一个程序来对给出的编号打印出所有的有效名字，如果没有则输出NONE。编号可能有12位数字。\n\n## 输入格式\n\n第一行一行包含一个编号(长度可能从1到12)。\n接下来4617行，每行一个字符串表示可以被接受的名字\n\n## 输出格式\n\n(file namenum.out)\n以字典顺序输出一个有效名字的不重复列表，一行一个名字。 如果没有有效名字，输出'NONE'。 //注释：似乎数字只有8^4种排列（1与0不能用）\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n4734\nNMSL\nGREG\nLSDC\n....(太多了不写了)\n```\n\n**输出：**\n```\nGREG\n```\n\n", "reason": "No valid samples found or contained Chinese"}
{"prompt": "你将得到一个编程竞赛题目。请逐步推理解决方案，然后用C或C++提供完整的实现。请勿包含任何调试信息或额外输出。将最终解决方案放在单个代码块中：\n```cpp\n<your code here>\n```\n\n\n题目内容:\n\n# P3864 [USACO1.2] 命名那个数字 Name That Number\n\n\n## 题目描述\n\n在威斯康辛州牛守志大农场经营者之中，都习惯于请会计部门用连续数字给母牛打上烙印。但是,母牛本身并没感到这个系统的便利,它们更喜欢用它们喜欢的名字来呼叫它们的同伴，而不是用像这个的语句\"C'mon, #4364, get along.\"。请写一个程序来帮助可怜的牧牛工将一只母牛的烙印编号翻译成一个可能的名字。因为母牛们现在都有手机了，使用标准的按键的排布来把将数目翻译为文字:( 除了 \"Q\" 和 \"Z\")\n```\n2: A,B,C     5: J,K,L    8: T,U,V\n3: D,E,F     6: M,N,O    9: W,X,Y\n4: G,H,I     7: P,R,S\n```\n\n可接受的名字都被放在这样一个叫作\"dict.txt\" 的文件中，它包含一连串的少于 5,000个（准确地说是4617个）可被接受的牛的名字。 (所有的名字都是大写的且已按字典序排列) 请读入母牛的编号并返回那些能从编号翻译出来并且在字典中的名字。举例来说,编号 4734 能产生的下列各项名字: GPDG GPDH GPDI GPEG GPEH GPEI GPFG GPFH GPFI GRDG GRDH GRDI GREG GREH GREI GRFG GRFH GRFI GSDG GSDH GSDI GSEG GSEH GSEI GSFG GSFH GSFI HPDG HPDH HPDI HPEG HPEH HPEI HPFG HPFH HPFI HRDG HRDH HRDI HREG HREH HREI HRFG HRFH HRFI HSDG HSDH HSDI HSEG HSEH HSEI HSFG HSFH HSFI IPDG IPDH IPDI IPEG IPEH IPEI IPFG IPFH IPFI IRDG IRDH IRDI IREG IREH IREI IRFG IRFH IRFI ISDG ISDH ISDI ISEG ISEH ISEI ISFG ISFH ISFI 碰巧，81个中只有一个\"GREG\"是有效的(在字典中)。\n写一个程序来对给出的编号打印出所有的有效名字，如果没有则输出NONE。编号可能有12位数字。\n\n## 输入格式\n\n第一行一行包含一个编号(长度可能从1到12)。\n接下来4617行，每行一个字符串表示可以被接受的名字\n\n## 输出格式\n\n(file namenum.out)\n以字典顺序输出一个有效名字的不重复列表，一行一个名字。 如果没有有效名字，输出'NONE'。 //注释：似乎数字只有8^4种排列（1与0不能用）\n\n## 样例\n\n### 样例 1\n\n**输入：**\n```\n4734\nNMSL\nGREG\nLSDC\n....(太多了不写了)\n```\n\n**输出：**\n```\nGREG\n```\n\n", "reason": "No valid samples found or contained Chinese"}
